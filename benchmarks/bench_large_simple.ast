// Large benchmark: Complex program with many functions (simplified for Core-0)
// Purpose: Stress test compilation performance

// Mathematical functions
fn abs(x: i32) -> i32 {
    if x < 0 { return -x; } else { return x; }
}

fn min(a: i32, b: i32) -> i32 {
    if a < b { return a; } else { return b; }
}

fn max(a: i32, b: i32) -> i32 {
    if a > b { return a; } else { return b; }
}

fn clamp(x: i32, low: i32, high: i32) -> i32 {
    return max(low, min(high, x));
}

// Number theory
fn power(base: i32, exp: i32) -> i32 {
    if exp == 0 {
        return 1;
    }
    let half = power(base, exp / 2);
    if exp % 2 == 0 {
        return half * half;
    } else {
        return base * half * half;
    }
}

fn fibonacci_iter(n: i32) -> i32 {
    if n <= 1 {
        return n;
    }
    let mut a = 0;
    let mut b = 1;
    let mut i = 2;
    while i <= n {
        let temp = a + b;
        a = b;
        b = temp;
        i = i + 1;
    }
    return b;
}

fn factorial_iter(n: i32) -> i32 {
    let mut result = 1;
    let mut i = 2;
    while i <= n {
        result = result * i;
        i = i + 1;
    }
    return result;
}

fn sum_of_divisors(n: i32) -> i32 {
    let mut sum = 0;
    let mut i = 1;
    while i <= n / 2 {
        if n % i == 0 {
            sum = sum + i;
        }
        i = i + 1;
    }
    return sum + n;
}

fn count_digits(n: i32) -> i32 {
    let mut count = 0;
    let mut num = abs(n);
    while num > 0 {
        count = count + 1;
        num = num / 10;
    }
    return if count == 0 { 1 } else { count };
}

fn reverse_number(n: i32) -> i32 {
    let mut result = 0;
    let mut num = abs(n);
    while num > 0 {
        result = result * 10 + num % 10;
        num = num / 10;
    }
    return if n < 0 { -result } else { result };
}

fn is_palindrome(n: i32) -> bool {
    return n == reverse_number(n);
}

fn sum_of_squares(n: i32) -> i32 {
    let mut sum = 0;
    let mut i = 1;
    while i <= n {
        sum = sum + i * i;
        i = i + 1;
    }
    return sum;
}

fn sum_of_cubes(n: i32) -> i32 {
    let mut sum = 0;
    let mut i = 1;
    while i <= n {
        sum = sum + i * i * i;
        i = i + 1;
    }
    return sum;
}

fn gcd(a: i32, b: i32) -> i32 {
    if b == 0 {
        return a;
    }
    return gcd(b, a % b);
}

fn lcm(a: i32, b: i32) -> i32 {
    return (a * b) / gcd(a, b);
}

fn is_prime(n: i32) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false;
    }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i = i + 6;
    }
    return true;
}

fn count_primes(limit: i32) -> i32 {
    let mut count = 0;
    let mut i = 2;
    while i < limit {
        if is_prime(i) {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
}

fn collatz_length(n: i32) -> i32 {
    let mut length = 0;
    let mut current = n;
    while current != 1 {
        if current % 2 == 0 {
            current = current / 2;
        } else {
            current = 3 * current + 1;
        }
        length = length + 1;
    }
    return length;
}

fn longest_collatz(limit: i32) -> i32 {
    let mut max_length = 0;
    let mut number_with_max = 0;
    let mut i = 1;
    while i < limit {
        let length = collatz_length(i);
        if length > max_length {
            max_length = length;
            number_with_max = i;
        }
        i = i + 1;
    }
    return number_with_max;
}

// Main function with comprehensive tests
fn main() -> i32 {
    // Math operations
    let fib_20 = fibonacci_iter(20);
    let fact_10 = factorial_iter(10);
    let pow_result = power(2, 10);
    
    // Number properties
    let digit_count = count_digits(12345);
    let reversed = reverse_number(12345);
    let is_pal = is_palindrome(12321);
    
    // Aggregate results
    let sum_sq = sum_of_squares(10);
    let sum_cu = sum_of_cubes(10);
    let div_sum = sum_of_divisors(28);
    
    // Prime counting
    let prime_count = count_primes(50);
    
    // GCD/LCM
    let gcd_result = gcd(48, 18);
    let lcm_result = lcm(12, 18);
    
    // Collatz sequence
    let collatz_max = longest_collatz(100);
    
    let result = fib_20 + fact_10 + pow_result + digit_count + prime_count;
    
    return result;
}
