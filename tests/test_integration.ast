// Integration Test Suite
// Tests complete compilation pipeline with realistic scenarios

fn main() -> i32 {
    // Test various algorithmic scenarios
    let fib_result: i32 = fibonacci(10);
    let fact_result: i32 = factorial(5);
    let gcd_result: i32 = gcd(48, 18);
    let prime_count: i32 = count_primes(20);
    let collatz_result: i32 = collatz_length(27);
    let sum_sq: i32 = sum_of_squares(10);
    
    // Validate results
    let all_tests_pass: bool = 
        fib_result == 55 &&
        fact_result == 120 &&
        gcd_result == 6 &&
        prime_count == 8 &&
        collatz_result == 111 &&
        sum_sq == 385;
    
    if all_tests_pass {
        0  // Success
    } else {
        1  // Failure
    }
}

// Fibonacci sequence (recursive)
fn fibonacci(n: i32) -> i32 {
    if n <= 1 {
        n
    } else {
        fibonacci(n - 1) + fibonacci(n - 2)
    }
}

// Factorial (recursive)
fn factorial(n: i32) -> i32 {
    if n <= 1 {
        1
    } else {
        n * factorial(n - 1)
    }
}

// Greatest Common Divisor (iterative)
fn gcd(a: i32, b: i32) -> i32 {
    let mut x: i32 = a;
    let mut y: i32 = b;
    
    while y != 0 {
        let temp: i32 = y;
        y = x % y;
        x = temp;
    }
    
    x
}

// Count prime numbers up to n
fn count_primes(n: i32) -> i32 {
    let mut count: i32 = 0;
    let mut i: i32 = 2;
    
    while i <= n {
        if is_prime(i) {
            count = count + 1;
        }
        i = i + 1;
    }
    
    count
}

// Check if number is prime
fn is_prime(n: i32) -> bool {
    if n < 2 {
        false
    } else if n == 2 {
        true
    } else if n % 2 == 0 {
        false
    } else {
        let mut i: i32 = 3;
        let mut is_prime_flag: bool = true;
        
        while i * i <= n {
            if n % i == 0 {
                is_prime_flag = false;
            }
            i = i + 2;
        }
        
        is_prime_flag
    }
}

// Collatz conjecture length
fn collatz_length(n: i32) -> i32 {
    let mut length: i32 = 0;
    let mut current: i32 = n;
    
    while current != 1 {
        if current % 2 == 0 {
            current = current / 2;
        } else {
            current = 3 * current + 1;
        }
        length = length + 1;
    }
    
    length
}

// Sum of squares from 1 to n
fn sum_of_squares(n: i32) -> i32 {
    let mut sum: i32 = 0;
    let mut i: i32 = 1;
    
    while i <= n {
        sum = sum + i * i;
        i = i + 1;
    }
    
    sum
}

// Power function
fn power(base: i32, exp: i32) -> i32 {
    if exp == 0 {
        1
    } else if exp == 1 {
        base
    } else {
        let half: i32 = power(base, exp / 2);
        if exp % 2 == 0 {
            half * half
        } else {
            base * half * half
        }
    }
}

// Least Common Multiple
fn lcm(a: i32, b: i32) -> i32 {
    (a * b) / gcd(a, b)
}
