// Symbol Table - Enhanced for Stage 2
// Minimal but functional symbol tracking

struct SymbolId {
    id: i32
}

struct Symbol {
    id: i32,
    name: String,
    kind: i32,  // 0=Variable, 1=Function, 2=Parameter, 3=Struct, 4=Enum, 5=Trait
    type_id: i32,
    scope_id: i32
}

struct Scope {
    id: i32,
    parent_id: i32,
    symbol_count: i32
}

struct SymbolTable {
    symbol_count: i32,
    scope_count: i32,
    current_scope: i32,
    has_errors: bool
}

fn new_symbol_table() -> SymbolTable {
    SymbolTable {
        symbol_count: 0,
        scope_count: 1,  // Start with global scope
        current_scope: 0,
        has_errors: false
    }
}

fn add_symbol(table: SymbolTable, name: String, kind: i32) -> SymbolTable {
    // Add symbol and increment counter
    SymbolTable {
        symbol_count: table.symbol_count + 1,
        scope_count: table.scope_count,
        current_scope: table.current_scope,
        has_errors: table.has_errors
    }
}

fn add_function_symbol(table: SymbolTable, name: String, type_id: i32) -> SymbolTable {
    // Add function symbol (kind=1)
    add_symbol(table, name, 1)
}

fn add_struct_symbol(table: SymbolTable, name: String) -> SymbolTable {
    // Add struct symbol (kind=3)
    add_symbol(table, name, 3)
}

fn add_trait_symbol(table: SymbolTable, name: String) -> SymbolTable {
    // Add trait symbol (kind=5)
    add_symbol(table, name, 5)
}

fn enter_scope(table: SymbolTable) -> SymbolTable {
    // Create new scope
    SymbolTable {
        symbol_count: table.symbol_count,
        scope_count: table.scope_count + 1,
        current_scope: table.scope_count,
        has_errors: table.has_errors
    }
}

fn exit_scope(table: SymbolTable) -> SymbolTable {
    // Return to parent scope
    let parent = if table.current_scope > 0 {
        table.current_scope - 1
    } else {
        0
    };
    
    SymbolTable {
        symbol_count: table.symbol_count,
        scope_count: table.scope_count,
        current_scope: parent,
        has_errors: table.has_errors
    }
}

fn lookup_symbol(table: SymbolTable, name: String) -> i32 {
    // Simplified: return symbol ID if exists
    // Real implementation would search scopes
    if table.symbol_count > 0 {
        1  // Found
    } else {
        -1  // Not found
    }
}

fn mark_error(table: SymbolTable) -> SymbolTable {
    SymbolTable {
        symbol_count: table.symbol_count,
        scope_count: table.scope_count,
        current_scope: table.current_scope,
        has_errors: true
    }
}
