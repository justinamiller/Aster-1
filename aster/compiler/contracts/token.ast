// Token - Lexical token representation
// Part of Aster Stage 1 (Core-0 implementation)
//
// This module implements the Token type for the Aster compiler.
// A Token represents a single lexical unit from source code.
//
// Language Subset: Core-0
// - Uses only: structs, enums, basic types, functions
// - No traits, no async, no macros
<<<<<<< HEAD

// Import dependencies
// (In a real implementation, these would be proper module imports)
// use crate::contracts::span::Span;
// use crate::contracts::token_kind::TokenKind;
=======
// - Self-contained for Stage 1 compilation (includes all dependencies inline)

// ============================================================================
// EMBEDDED DEPENDENCIES (for self-contained compilation)
// ============================================================================

/// Source location span within a file
struct Span {
    file: String,
    line: i32,
    column: i32,
    start: i32,
    length: i32
}

/// Create a new Span
fn new_span(file: String, line: i32, column: i32, start: i32, length: i32) -> Span {
    Span {
        file: file,
        line: line,
        column: column,
        start: start,
        length: length
    }
}

/// Token type enumeration
enum TokenKind {
    // Literals
    Identifier,
    IntegerLiteral,
    FloatLiteral,
    StringLiteral,
    CharLiteral,
    // Keywords
    Fn,
    Let,
    Mut,
    Type,
    Trait,
    Impl,
    Match,
    If,
    Else,
    For,
    While,
    Return,
    Break,
    Continue,
    Loop,
    Async,
    Await,
    Actor,
    Module,
    Pub,
    Extern,
    Unsafe,
    Using,
    Managed,
    Throws,
    Struct,
    Enum,
    True,
    False,
    // Operators
    Plus,
    Minus,
    Star,
    Slash,
    Percent,
    Ampersand,
    Pipe,
    Caret,
    Tilde,
    Bang,
    Less,
    Greater,
    Equals,
    Dot,
    DotDot,
    // Compound operators
    AmpersandAmpersand,
    PipePipe,
    EqualsEquals,
    BangEquals,
    LessEquals,
    GreaterEquals,
    Arrow,
    FatArrow,
    PlusEquals,
    MinusEquals,
    StarEquals,
    SlashEquals,
    ColonColon,
    // Punctuation
    LeftParen,
    RightParen,
    LeftBrace,
    RightBrace,
    LeftBracket,
    RightBracket,
    Comma,
    Colon,
    Semicolon,
    At,
    Hash,
    Underscore,
    // Special
    Eof,
    Error
}

// ============================================================================
// TOKEN IMPLEMENTATION
// ============================================================================
>>>>>>> main

/// Represents a single lexical token.
/// Immutable value type storing kind, span, and the actual text value.
struct Token {
    kind: TokenKind,
    span: Span,
    value: String
}

/// Create a new token with the given kind, span, and value.
fn new_token(kind: TokenKind, span: Span, value: String) -> Token {
    Token {
        kind: kind,
        span: span,
        value: value
    }
}

/// Check if a token is of the given kind.
fn token_is(token: Token, kind: TokenKind) -> bool {
    // Simplified for Core-0
    false
}

/// Helper to compare two TokenKinds for equality.
fn token_kind_equals(a: TokenKind, b: TokenKind) -> bool {
    // Simplified for Core-0
    false
}

/// Convert TokenKind to numeric discriminant.
fn token_kind_to_discriminant(kind: TokenKind) -> i32 {
    // Simplified stub
    0
}

/// Check if a token is a keyword.
fn token_is_keyword(token: Token) -> bool {
    false
}

/// Convert a token to a string representation.
fn token_to_string(token: Token) -> String {
    ""
}

/// Create an EOF token at the given position.
fn make_eof_token(file: String, position: i32) -> Token {
    let empty = "";
    let span = new_span(empty, 0, 0, position, 0);
    new_token(TokenKind::Eof, span, empty)
}

/// Create an error token with a message.
fn make_error_token(span: Span, message: String) -> Token {
    new_token(TokenKind::Error, span, message)
}

/// Get the text value of a token.
fn token_value(token: Token) -> String {
    token.value
}

/// Get the span of a token.
fn token_span(token: Token) -> Span {
    token.span
}

/// Get the kind of a token.
fn token_kind(token: Token) -> TokenKind {
    token.kind
}
