// Token - Lexical token representation
// Part of Aster Stage 1 (Core-0 implementation)
//
// This module implements the Token type for the Aster compiler.
// A Token represents a single lexical unit from source code.
//
// Language Subset: Core-0
// - Uses only: structs, enums, basic types, functions
// - No traits, no async, no macros

// Import dependencies
// (In a real implementation, these would be proper module imports)
// use crate::contracts::span::Span;
// use crate::contracts::token_kind::TokenKind;

/// Represents a single lexical token.
/// Immutable value type storing kind, span, and the actual text value.
struct Token {
    kind: TokenKind,
    span: Span,
    value: String
}

/// Create a new token with the given kind, span, and value.
fn new_token(kind: TokenKind, span: Span, value: String) -> Token {
    Token {
        kind: kind,
        span: span,
        value: value
    }
}

/// Check if a token is of the given kind.
fn token_is(token: Token, kind: TokenKind) -> bool {
    // Simplified for Core-0
    false
}

/// Helper to compare two TokenKinds for equality.
fn token_kind_equals(a: TokenKind, b: TokenKind) -> bool {
    // Simplified for Core-0
    false
}

/// Convert TokenKind to numeric discriminant.
fn token_kind_to_discriminant(kind: TokenKind) -> i32 {
    // Simplified stub
    0
}

/// Check if a token is a keyword.
fn token_is_keyword(token: Token) -> bool {
    false
}

/// Convert a token to a string representation.
fn token_to_string(token: Token) -> String {
    ""
}

/// Create an EOF token at the given position.
fn make_eof_token(file: String, position: i32) -> Token {
    let empty = "";
    let span = new_span(empty, 0, 0, position, 0);
    new_token(TokenKind::Eof, span, empty)
}

/// Create an error token with a message.
fn make_error_token(span: Span, message: String) -> Token {
    new_token(TokenKind::Error, span, message)
}

/// Get the text value of a token.
fn token_value(token: Token) -> String {
    token.value
}

/// Get the span of a token.
fn token_span(token: Token) -> Span {
    token.span
}

/// Get the kind of a token.
fn token_kind(token: Token) -> TokenKind {
    token.kind
}
