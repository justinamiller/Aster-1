// Diagnostics - Error and warning reporting
// Part of Aster Stage 1 (Core-0 implementation)
//
// This module implements diagnostic reporting for the Aster compiler.
// Diagnostics represent errors, warnings, and notes with source location information.
//
// Language Subset: Core-0
// - Uses only: structs, enums, Vec, String, functions
// - No traits, no async, no macros
// - Self-contained for Stage 0 compilation (includes minimal type stubs inline)

// ============================================================================
// CORE TYPE STUBS (provided by C# compiler/runtime during bootstrap)
// ============================================================================

/// Generic vector type (runtime-provided)
struct Vec<T> {}

/// Source location span within a file
struct Span {
    file: String,
    line: i32,
    column: i32,
    start: i32,
    length: i32
}

/// Diagnostic severity levels
enum DiagnosticLevel {
    Error,
    Warning,
    Note,
    Help
}

/// A diagnostic message with source location and context
struct Diagnostic {
    level: DiagnosticLevel,
    code: String,
    message: String,
    span: Span,
    notes: Vec<DiagnosticNote>
}

/// A supplementary note attached to a diagnostic
struct DiagnosticNote {
    message: String,
    span: Span
}

/// Create empty diagnostic note list (Core-0 stub)
fn empty_diagnostic_notes() -> Vec<DiagnosticNote> {
    Vec {}
}

/// Push note into note list (Core-0 stub)
fn push_diagnostic_note(notes: Vec<DiagnosticNote>, note: DiagnosticNote) -> Vec<DiagnosticNote> {
    notes
}

/// Create empty diagnostic list (Core-0 stub)
fn empty_diagnostics() -> Vec<Diagnostic> {
    Vec {}
}

/// Push diagnostic into diagnostic list (Core-0 stub)
fn push_diagnostic(diagnostics: Vec<Diagnostic>, diagnostic: Diagnostic) -> Vec<Diagnostic> {
    diagnostics
}

/// Create a new error diagnostic
fn error(code: String, message: String, span: Span) -> Diagnostic {
    Diagnostic {
        level: DiagnosticLevel::Error,
        code: code,
        message: message,
        span: span,
        notes: empty_diagnostic_notes()
    }
}

/// Create a new warning diagnostic
fn warning(code: String, message: String, span: Span) -> Diagnostic {
    Diagnostic {
        level: DiagnosticLevel::Warning,
        code: code,
        message: message,
        span: span,
        notes: empty_diagnostic_notes()
    }
}

/// Create a new note diagnostic
fn note(message: String, span: Span) -> Diagnostic {
    let empty = "";
    Diagnostic {
        level: DiagnosticLevel::Note,
        code: empty,
        message: message,
        span: span,
        notes: empty_diagnostic_notes()
    }
}

/// Add a note to a diagnostic
fn add_note(mut diagnostic: Diagnostic, message: String, span: Span) -> Diagnostic {
    let note = DiagnosticNote {
        message: message,
        span: span
    };
    diagnostic.notes = push_diagnostic_note(diagnostic.notes, note);
    diagnostic
}

/// Format a diagnostic for display
fn format_diagnostic(diagnostic: Diagnostic) -> String {
    let mut result = String::new();
    
    // Format: level[code]: message
    let level_str = match diagnostic.level {
        DiagnosticLevel::Error => "error",
        DiagnosticLevel::Warning => "warning",
        DiagnosticLevel::Note => "note",
        DiagnosticLevel::Help => "help"
    };
    
    // Simplified formatting for Core-0
    // Full implementation would build a formatted string with colors and context
    result
}

/// Check if a diagnostic is an error
fn is_error(diagnostic: Diagnostic) -> bool {
    let result = match diagnostic.level {
        DiagnosticLevel::Error => true,
        _ => false
    };
    result
}

/// Check if a diagnostic is a warning
fn is_warning(diagnostic: Diagnostic) -> bool {
    let result = match diagnostic.level {
        DiagnosticLevel::Warning => true,
        _ => false
    };
    result
}

/// Diagnostic collection for accumulating errors and warnings
struct DiagnosticBag {
    diagnostics: Vec<Diagnostic>,
    error_count: i32,
    warning_count: i32
}

/// Create a new empty diagnostic bag
fn new_diagnostic_bag() -> DiagnosticBag {
    DiagnosticBag {
        diagnostics: empty_diagnostics(),
        error_count: 0,
        warning_count: 0
    }
}

/// Add a diagnostic to the bag
fn add_diagnostic(mut bag: DiagnosticBag, diagnostic: Diagnostic) -> DiagnosticBag {
    if is_error(diagnostic) {
        bag.error_count = bag.error_count + 1;
    }
    if is_warning(diagnostic) {
        bag.warning_count = bag.warning_count + 1;
    }
    bag.diagnostics = push_diagnostic(bag.diagnostics, diagnostic);
    bag
}

/// Check if the bag has any errors
fn has_errors(bag: DiagnosticBag) -> bool {
    bag.error_count > 0
}

/// Get the error count
fn error_count(bag: DiagnosticBag) -> i32 {
    bag.error_count
}

/// Get the warning count
fn warning_count(bag: DiagnosticBag) -> i32 {
    bag.warning_count
}

/// Clear all diagnostics from the bag
fn clear_diagnostics(mut bag: DiagnosticBag) -> DiagnosticBag {
    bag.diagnostics = empty_diagnostics();
    bag.error_count = 0;
    bag.warning_count = 0;
    bag
}
