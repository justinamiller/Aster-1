// Diagnostics - Error and warning reporting
// Part of Aster Stage 1 (Core-0 implementation)
//
// This module implements diagnostic reporting for the Aster compiler.
// Diagnostics represent errors, warnings, and notes with source location information.
//
// Language Subset: Core-0
// - Uses only: structs, enums, Vec, String, functions
// - No traits, no async, no macros
// - Self-contained for Stage 1 compilation (includes all dependencies inline)

// ============================================================================
// EMBEDDED DEPENDENCIES (for self-contained compilation)
// ============================================================================

/// Source location span within a file
struct Span {
    file: String,
    line: i32,
    column: i32,
    start: i32,
    length: i32
}

/// Create a new Span
fn new_span(file: String, line: i32, column: i32, start: i32, length: i32) -> Span {
    Span {
        file: file,
        line: line,
        column: column,
        start: start,
        length: length
    }
}

/// Generic vector type (provided by runtime)
struct Vec<T> {}

// ============================================================================
// DIAGNOSTICS IMPLEMENTATION
// ============================================================================

/// Diagnostic severity levels
enum DiagnosticLevel {
    Error,
    Warning,
    Note,
    Help
}

/// A diagnostic message with source location and context
struct Diagnostic {
    level: DiagnosticLevel,
    code: String,
    message: String,
    span: Span,
    notes: Vec<DiagnosticNote>
}

/// A supplementary note attached to a diagnostic
struct DiagnosticNote {
    message: String,
    span: Span
}

/// Create a new error diagnostic
fn error(code: String, message: String, span: Span) -> Diagnostic {
    Diagnostic {
        level: DiagnosticLevel::Error,
        code: code,
        message: message,
        span: span,
        notes: Vec {}
    }
}

/// Create a new warning diagnostic
fn warning(code: String, message: String, span: Span) -> Diagnostic {
    Diagnostic {
        level: DiagnosticLevel::Warning,
        code: code,
        message: message,
        span: span,
        notes: Vec {}
    }
}

/// Create a new note diagnostic
fn note(message: String, span: Span) -> Diagnostic {
    let empty = "";
    Diagnostic {
        level: DiagnosticLevel::Note,
        code: empty,
        message: message,
        span: span,
        notes: Vec {}
    }
}

/// Add a note to a diagnostic (stub for Core-0)
fn add_note(diagnostic: Diagnostic, message: String, span: Span) -> Diagnostic {
    // Simplified for Core-0 - doesn't actually add the note
    // Full implementation would use Vec::push
    diagnostic
}

/// Format a diagnostic for display
fn format_diagnostic(diagnostic: Diagnostic) -> String {
    let mut result = String::new();
    
    // Format: level[code]: message
    let level_str = match diagnostic.level {
        DiagnosticLevel::Error => "error",
        DiagnosticLevel::Warning => "warning",
        DiagnosticLevel::Note => "note",
        DiagnosticLevel::Help => "help"
    };
    
    // Simplified formatting for Core-0
    // Full implementation would build a formatted string with colors and context
    result
}

/// Check if a diagnostic is an error
fn is_error(diagnostic: Diagnostic) -> bool {
    let result = match diagnostic.level {
        DiagnosticLevel::Error => true,
        _ => false
    };
    result
}

/// Check if a diagnostic is a warning
fn is_warning(diagnostic: Diagnostic) -> bool {
    let result = match diagnostic.level {
        DiagnosticLevel::Warning => true,
        _ => false
    };
    result
}

/// Diagnostic collection for accumulating errors and warnings
struct DiagnosticBag {
    diagnostics: Vec<Diagnostic>,
    error_count: i32,
    warning_count: i32
}

/// Create a new empty diagnostic bag
fn new_diagnostic_bag() -> DiagnosticBag {
    DiagnosticBag {
        diagnostics: Vec {},
        error_count: 0,
        warning_count: 0
    }
}

/// Add a diagnostic to the bag (stub for Core-0)
fn add_diagnostic(mut bag: DiagnosticBag, diagnostic: Diagnostic) -> DiagnosticBag {
    if is_error(diagnostic) {
        bag.error_count = bag.error_count + 1;
    }
    if is_warning(diagnostic) {
        bag.warning_count = bag.warning_count + 1;
    }
    // Simplified for Core-0 - doesn't actually add to the list
    // Full implementation would use Vec::push
    bag
}

/// Check if the bag has any errors
fn has_errors(bag: DiagnosticBag) -> bool {
    bag.error_count > 0
}

/// Get the error count
fn error_count(bag: DiagnosticBag) -> i32 {
    bag.error_count
}

/// Get the warning count
fn warning_count(bag: DiagnosticBag) -> i32 {
    bag.warning_count
}

/// Clear all diagnostics from the bag
fn clear_diagnostics(mut bag: DiagnosticBag) -> DiagnosticBag {
    bag.diagnostics = Vec {};
    bag.error_count = 0;
    bag.warning_count = 0;
    bag
}
