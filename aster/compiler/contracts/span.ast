// Span - Source location tracking
// Part of Aster Stage 1 (Core-0 implementation)
//
// This module implements source span tracking for the Aster compiler.
// A Span represents a location in source code with file, line, column,
// start offset, and length information.
//
// Language Subset: Core-0
// - Uses only: structs, basic types, functions
// - No traits, no async, no macros

/// Represents a source location span within a file.
/// Immutable value type tracking file, line, column, start offset, and length.
struct Span {
    file: String,
    line: i32,
    column: i32,
    start: i32,
    length: i32
}

/// Create a new Span with the given parameters.
fn new_span(file: String, line: i32, column: i32, start: i32, length: i32) -> Span {
    Span {
        file: file,
        line: line,
        column: column,
        start: start,
        length: length
    }
}

/// A sentinel span representing an unknown or synthetic location.
fn unknown_span() -> Span {
    let empty_string = "";
    Span {
        file: empty_string,
        line: 0,
        column: 0,
        start: 0,
        length: 0
    }
}

/// Get the end offset of the span (exclusive).
fn span_end(span: Span) -> i32 {
    span.start + span.length
}

/// Convert span to a string representation for error messages.
/// Format: "file:line:column"
fn span_to_string(span: Span) -> String {
    let mut result = "";
    // Note: Simplified - full implementation would build string
    result
}

/// Check if two spans are equal.
fn spans_equal(a: Span, b: Span) -> bool {
    a.file == b.file &&
    a.line == b.line &&
    a.column == b.column &&
    a.start == b.start &&
    a.length == b.length
}

/// Combine two spans to create a span that covers both.
fn span_combine(a: Span, b: Span) -> Span {
    let start = if a.start < b.start { a.start } else { b.start };
    let a_end = a.start + a.length;
    let b_end = b.start + b.length;
    let end = if a_end > b_end { a_end } else { b_end };
    
    Span {
        file: a.file,
        line: a.line,
        column: a.column,
        start: start,
        length: end - start
    }
}
