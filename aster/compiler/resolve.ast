// Name Resolution - Implementation for Stage 1
// Part of Aster Stage 1 (Core-0 implementation)
//
// This module implements name resolution, which maps identifiers to their
// definitions and checks for undefined names, duplicate definitions, etc.
//
// Language Subset: Core-0
// - Uses only: structs, enums, Vec, String, functions
// - No traits, no HashMap, no methods
// - All functions are standalone

// ============================================================================
// EMBEDDED DEPENDENCIES (for self-contained compilation)
// ============================================================================

/// Generic vector type (provided by runtime)
struct Vec<T> {}

/// Source location span within a file
struct Span {
    file: String,
    line: i32,
    column: i32,
    start: i32,
    length: i32
}

// ============================================================================
// CORE DATA STRUCTURES
// ============================================================================

/// Kind of binding (what the name refers to)
enum BindingKind {
    Variable,
    Function,
    Struct,
    Enum,
    EnumVariant,
    TypeParameter,
    Parameter
}

/// A single name binding in a scope
struct Binding {
    name: String,
    kind: BindingKind,
    defined_at: Span,
    binding_id: i32
}

/// A lexical scope containing bindings
struct Scope {
    bindings: Vec<Binding>,
    binding_count: i32,
    scope_id: i32
}

/// Name resolver state with scope stack
struct NameResolver {
    scopes: Vec<Scope>,
    scope_count: i32,
    next_binding_id: i32,
    errors: Vec<ResolutionError>,
    error_count: i32
}

/// Resolution error
struct ResolutionError {
    message: String,
    span: Span
}

/// Result of looking up a name
struct LookupResult {
    found: bool,
    binding: Binding,
    scope_depth: i32
}

/// Resolved identifier information
struct ResolvedName {
    name: String,
    is_defined: bool,
    binding_id: i32
}

/// Result of name resolution
struct NameResolveResult {
    resolver: NameResolver,
    success: bool
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/// Create a new empty scope
fn new_scope(scope_id: i32) -> Scope {
    Scope {
        bindings: Vec::new(),
        binding_count: 0,
        scope_id: scope_id
    }
}

/// Create a new binding
fn new_binding(name: String, kind: BindingKind, span: Span, id: i32) -> Binding {
    Binding {
        name: name,
        kind: kind,
        defined_at: span,
        binding_id: id
    }
}

/// Create a dummy binding for error cases
fn dummy_binding() -> Binding {
    let empty = "";
    let dummy_span = Span {
        file: empty,
        line: 0,
        column: 0,
        start: 0,
        length: 0
    };
    new_binding(String::from(""), BindingKind::Variable, dummy_span, -1)
}

/// Create a new resolution error
fn new_resolution_error(message: String, span: Span) -> ResolutionError {
    ResolutionError {
        message: message,
        span: span
    }
}

// ============================================================================
// NAME RESOLVER INITIALIZATION
// ============================================================================

/// Create a new name resolver
fn new_name_resolver() -> NameResolver {
    let mut resolver = NameResolver {
        scopes: Vec::new(),
        scope_count: 0,
        next_binding_id: 0,
        errors: Vec::new(),
        error_count: 0
    };
    
    // Create the initial global scope
    let global_scope = new_scope(0);
    resolver.scope_count = 1;
    
    resolver
}

// ============================================================================
// SCOPE MANAGEMENT
// ============================================================================

/// Enter a new scope (push onto stack)
fn enter_scope(mut resolver: NameResolver) -> NameResolver {
    let new_scope_val = new_scope(resolver.scope_count);
    resolver.scope_count = resolver.scope_count + 1;
    // In actual implementation, would push new_scope_val onto scopes vector
    resolver
}

/// Exit current scope (pop from stack)
fn exit_scope(mut resolver: NameResolver) -> NameResolver {
    // In actual implementation, would pop from scopes vector
    // For now, just return resolver
    resolver
}

/// Get the depth of the current scope (0 = global)
fn scope_depth(resolver: NameResolver) -> i32 {
    // In actual implementation, would return scopes.len() - 1
    // For now, return 0
    0
}

// ============================================================================
// NAME BINDING
// ============================================================================

/// Define a name in the current scope
fn define_in_scope(mut resolver: NameResolver, name: String, kind: BindingKind, span: Span) -> NameResolver {
    // Check for duplicate in current scope
    let lookup = lookup_in_current_scope(resolver, name);
    resolver = lookup.resolver;
    
    if lookup.result.found {
        // Duplicate definition error
        let error_msg = String::from("Duplicate definition");
        let error = new_resolution_error(error_msg, span);
        resolver.error_count = resolver.error_count + 1;
        return resolver;
    }
    
    // Create new binding
    let binding = new_binding(name, kind, span, resolver.next_binding_id);
    resolver.next_binding_id = resolver.next_binding_id + 1;
    
    // In actual implementation, would add binding to current scope
    // For now, just update resolver
    resolver
}

/// Define a name (simplified - for backward compatibility)
fn define_name(mut resolver: NameResolver, name: String) -> NameResolver {
    let empty = "";
    let dummy_span = Span {
        file: empty,
        line: 0,
        column: 0,
        start: 0,
        length: 0
    };
    define_in_scope(resolver, name, BindingKind::Variable, dummy_span)
}

// ============================================================================
// NAME LOOKUP
// ============================================================================

/// Intermediate lookup result with resolver
struct LookupWithResolver {
    resolver: NameResolver,
    result: LookupResult
}

/// Look up a name in the current scope only
fn lookup_in_current_scope(resolver: NameResolver, name: String) -> LookupWithResolver {
    // In actual implementation, would search bindings in current scope
    // For now, return not found
    let not_found = LookupResult {
        found: false,
        binding: dummy_binding(),
        scope_depth: 0
    };
    
    LookupWithResolver {
        resolver: resolver,
        result: not_found
    }
}

/// Look up a name in all scopes (current to global)
fn lookup_name(resolver: NameResolver, name: String) -> LookupWithResolver {
    // In actual implementation, would search from current scope up to global
    // For now, return not found
    let not_found = LookupResult {
        found: false,
        binding: dummy_binding(),
        scope_depth: 0
    };
    
    LookupWithResolver {
        resolver: resolver,
        result: not_found
    }
}

/// Resolve a name (simplified - always succeeds for backward compatibility)
fn resolve_name(resolver: NameResolver, name: String) -> ResolvedName {
    ResolvedName {
        name: name,
        is_defined: true,
        binding_id: -1
    }
}

// ============================================================================
// DECLARATION RESOLUTION
// ============================================================================

/// Resolve a function declaration
fn resolve_function_decl(mut resolver: NameResolver, name: String, span: Span) -> NameResolver {
    // Define function name in current scope
    resolver = define_in_scope(resolver, name, BindingKind::Function, span);
    
    // In actual implementation, would:
    // - Enter function scope
    // - Define parameters
    // - Resolve body
    // - Exit function scope
    
    resolver
}

/// Resolve a struct declaration
fn resolve_struct_decl(mut resolver: NameResolver, name: String, span: Span) -> NameResolver {
    // Define struct name in current scope
    resolver = define_in_scope(resolver, name, BindingKind::Struct, span);
    
    // In actual implementation, would:
    // - Enter struct scope
    // - Resolve field types
    // - Exit struct scope
    
    resolver
}

/// Resolve an enum declaration
fn resolve_enum_decl(mut resolver: NameResolver, name: String, span: Span) -> NameResolver {
    // Define enum name in current scope
    resolver = define_in_scope(resolver, name, BindingKind::Enum, span);
    
    // In actual implementation, would:
    // - Enter enum scope
    // - Define variants
    // - Exit enum scope
    
    resolver
}

/// Resolve a variable declaration
fn resolve_variable_decl(mut resolver: NameResolver, name: String, span: Span) -> NameResolver {
    // Define variable name in current scope
    resolver = define_in_scope(resolver, name, BindingKind::Variable, span);
    resolver
}

// ============================================================================
// MODULE RESOLUTION
// ============================================================================

/// Resolve all names in module (simplified)
fn resolve_module(mut resolver: NameResolver) -> NameResolveResult {
    // In actual implementation, would:
    // - Traverse all items in module
    // - Resolve each declaration
    // - Resolve all references
    
    // For now, just succeed if no errors
    let success = resolver.error_count == 0;
    
    NameResolveResult {
        resolver: resolver,
        success: success
    }
}

/// Add an error to the resolver
fn add_error(mut resolver: NameResolver, message: String, span: Span) -> NameResolver {
    let error = new_resolution_error(message, span);
    resolver.error_count = resolver.error_count + 1;
    resolver
}

/// Check if resolver has errors
fn has_errors(resolver: NameResolver) -> bool {
    resolver.error_count > 0
}
