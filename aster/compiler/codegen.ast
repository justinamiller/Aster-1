// Code Generation - HIR to C/LLVM code generation for Stage 1
// Part of Aster Stage 1 Bootstrap (Complete Implementation)

// Target backend selection
enum CodeGenTarget {
    C,          // Generate C code
    LLVM,       // Generate LLVM IR
    Assembly    // Generate assembly (future)
}

// Code generation context
struct CodeGenContext {
    functions: Vec<String>,
    globals: Vec<String>,
    indent_level: i32
}

// Main code generator
struct CodeGenerator {
    target: CodeGenTarget,
    context: CodeGenContext,
    errors: Vec<String>,
    error_count: i32
}

// Code buffer for output
struct CodeBuffer {
    content: String,
    line_count: i32
}

// Result structures (Core-0 compatible - no tuples)
struct CodeGenResult {
    generator: CodeGenerator,
    success: bool,
    output: String
}

struct GenerateFunctionResult {
    generator: CodeGenerator,
    code: String
}

struct GenerateExprResult {
    generator: CodeGenerator,
    code: String
}

struct GenerateStmtResult {
    generator: CodeGenerator,
    code: String
}

// ===== Factory Functions =====

fn new_code_generator(target: CodeGenTarget) -> CodeGenerator {
    CodeGenerator {
        target: target,
        context: new_code_gen_context(),
        errors: Vec::new(),
        error_count: 0
    }
}

fn new_code_gen_context() -> CodeGenContext {
    CodeGenContext {
        functions: Vec::new(),
        globals: Vec::new(),
        indent_level: 0
    }
}

fn new_code_buffer() -> CodeBuffer {
    CodeBuffer {
        content: "",
        line_count: 0
    }
}

// ===== Module Generation =====

/// Generate code for entire module
fn generate_module(mut gen: CodeGenerator, module: HirModule) -> CodeGenResult {
    let mut output = "";
    
    // Generate header
    output = output + "// Generated by Aster Compiler - Stage 1 Bootstrap\n\n";
    
    // Generate includes/imports based on target
    if gen.target == CodeGenTarget::C {
        output = output + "#include <stdint.h>\n";
        output = output + "#include <stdbool.h>\n";
        output = output + "#include <stdio.h>\n\n";
    }
    
    // Generate each function
    for func in module.functions {
        let result = generate_function(gen, func);
        gen = result.generator;
        output = output + result.code + "\n\n";
    }
    
    let success = gen.error_count == 0;
    
    CodeGenResult {
        generator: gen,
        success: success,
        output: output
    }
}

// ===== Function Generation =====

fn generate_function(mut gen: CodeGenerator, func: HirFunction) -> GenerateFunctionResult {
    let mut code = "";
    
    // Generate function signature
    code = code + generate_function_signature(func);
    code = code + " {\n";
    
    gen.context.indent_level = gen.context.indent_level + 1;
    
    // Generate local variable declarations
    code = code + generate_local_declarations(func.locals);
    
    // Generate function body
    let body_result = generate_block(gen, func.body);
    gen = body_result.generator;
    code = code + body_result.code;
    
    gen.context.indent_level = gen.context.indent_level - 1;
    code = code + "}\n";
    
    GenerateFunctionResult {
        generator: gen,
        code: code
    }
}

fn generate_function_signature(func: HirFunction) -> String {
    let return_type = generate_type(func.return_type);
    let params = generate_params(func.params);
    
    return_type + " " + func.name + "(" + params + ")"
}

fn generate_params(params: Vec<HirParam>) -> String {
    if params.is_empty() {
        return "void";
    }
    
    let mut result = "";
    let mut first = true;
    
    for param in params {
        if !first {
            result = result + ", ";
        }
        first = false;
        
        result = result + generate_type(param.type_id) + " " + param.name;
    }
    
    result
}

fn generate_local_declarations(locals: Vec<HirLocal>) -> String {
    let mut code = "";
    
    for local in locals {
        let type_str = generate_type(local.type_id);
        code = code + "    " + type_str + " " + local.name + ";\n";
    }
    
    if !locals.is_empty() {
        code = code + "\n";
    }
    
    code
}

// ===== Block & Statement Generation =====

fn generate_block(mut gen: CodeGenerator, block: HirBlock) -> GenerateStmtResult {
    let mut code = "";
    
    // Generate each statement
    for stmt in block.stmts {
        let result = generate_statement(gen, stmt);
        gen = result.generator;
        code = code + result.code;
    }
    
    // Generate result expression if present
    if block.result_expr != invalid_hir_expr() {
        let result = generate_expression(gen, block.result_expr);
        gen = result.generator;
        code = code + indent(gen.context.indent_level) + result.code + ";\n";
    }
    
    GenerateStmtResult {
        generator: gen,
        code: code
    }
}

fn generate_statement(mut gen: CodeGenerator, stmt: HirStatement) -> GenerateStmtResult {
    // Statement type dispatch
    if stmt.kind == StatementKind::Let {
        return generate_let_stmt(gen, stmt.let_stmt);
    } else if stmt.kind == StatementKind::Assign {
        return generate_assign_stmt(gen, stmt.assign_stmt);
    } else if stmt.kind == StatementKind::ExprStmt {
        return generate_expr_stmt(gen, stmt.expr_stmt);
    } else if stmt.kind == StatementKind::Return {
        return generate_return_stmt(gen, stmt.return_stmt);
    }
    
    // Empty statement
    GenerateStmtResult {
        generator: gen,
        code: ""
    }
}

fn generate_let_stmt(mut gen: CodeGenerator, stmt: HirLetStmt) -> GenerateStmtResult {
    let mut code = indent(gen.context.indent_level);
    
    code = code + stmt.name + " = ";
    
    if stmt.initializer != invalid_hir_expr() {
        let result = generate_expression(gen, stmt.initializer);
        gen = result.generator;
        code = code + result.code;
    } else {
        code = code + "0"; // Default initialization
    }
    
    code = code + ";\n";
    
    GenerateStmtResult {
        generator: gen,
        code: code
    }
}

fn generate_assign_stmt(mut gen: CodeGenerator, stmt: HirAssignStmt) -> GenerateStmtResult {
    let mut code = indent(gen.context.indent_level);
    
    // Generate left-hand side (place)
    code = code + generate_place(stmt.place);
    code = code + " = ";
    
    // Generate right-hand side
    let result = generate_expression(gen, stmt.value);
    gen = result.generator;
    code = code + result.code + ";\n";
    
    GenerateStmtResult {
        generator: gen,
        code: code
    }
}

fn generate_expr_stmt(mut gen: CodeGenerator, expr: HirExpression) -> GenerateStmtResult {
    let result = generate_expression(gen, expr);
    let code = indent(result.generator.context.indent_level) + result.code + ";\n";
    
    GenerateStmtResult {
        generator: result.generator,
        code: code
    }
}

fn generate_return_stmt(mut gen: CodeGenerator, stmt: HirReturnStmt) -> GenerateStmtResult {
    let mut code = indent(gen.context.indent_level) + "return";
    
    if stmt.value != invalid_hir_expr() {
        let result = generate_expression(gen, stmt.value);
        gen = result.generator;
        code = code + " " + result.code;
    }
    
    code = code + ";\n";
    
    GenerateStmtResult {
        generator: gen,
        code: code
    }
}

fn generate_place(place: HirPlace) -> String {
    if place.kind == PlaceKind::Local {
        return place.local_name;
    } else if place.kind == PlaceKind::Field {
        return place.base_name + "." + place.field_name;
    } else if place.kind == PlaceKind::Index {
        return place.base_name + "[" + place.index_expr + "]";
    }
    
    "unknown_place"
}

// ===== Expression Generation =====

fn generate_expression(mut gen: CodeGenerator, expr: HirExpression) -> GenerateExprResult {
    // Expression type dispatch
    if expr.kind == ExprKind::Literal {
        return generate_literal(gen, expr.literal);
    } else if expr.kind == ExprKind::Variable {
        return generate_variable(gen, expr.variable);
    } else if expr.kind == ExprKind::BinaryOp {
        return generate_binary_op(gen, expr.binary_op);
    } else if expr.kind == ExprKind::UnaryOp {
        return generate_unary_op(gen, expr.unary_op);
    } else if expr.kind == ExprKind::Call {
        return generate_call(gen, expr.call);
    } else if expr.kind == ExprKind::If {
        return generate_if(gen, expr.if_expr);
    } else if expr.kind == ExprKind::While {
        return generate_while(gen, expr.while_loop);
    } else if expr.kind == ExprKind::For {
        return generate_for(gen, expr.for_loop);
    } else if expr.kind == ExprKind::Match {
        return generate_match(gen, expr.match_expr);
    } else if expr.kind == ExprKind::Block {
        return generate_block_expr(gen, expr.block);
    } else if expr.kind == ExprKind::FieldAccess {
        return generate_field_access(gen, expr.field_access);
    } else if expr.kind == ExprKind::IndexAccess {
        return generate_index_access(gen, expr.index_access);
    } else if expr.kind == ExprKind::StructLit {
        return generate_struct_lit(gen, expr.struct_lit);
    } else if expr.kind == ExprKind::ArrayLit {
        return generate_array_lit(gen, expr.array_lit);
    }
    
    // Unknown expression
    GenerateExprResult {
        generator: gen,
        code: "0"
    }
}

fn generate_literal(gen: CodeGenerator, lit: HirLiteral) -> GenerateExprResult {
    let code = if lit.kind == LiteralKind::Int {
        int_to_string(lit.int_value)
    } else if lit.kind == LiteralKind::Float {
        float_to_string(lit.float_value)
    } else if lit.kind == LiteralKind::Bool {
        if lit.bool_value { "true" } else { "false" }
    } else if lit.kind == LiteralKind::String {
        "\"" + lit.string_value + "\""
    } else if lit.kind == LiteralKind::Char {
        "'" + lit.char_value + "'"
    } else {
        "0"
    };
    
    GenerateExprResult {
        generator: gen,
        code: code
    }
}

fn generate_variable(gen: CodeGenerator, var: HirVariable) -> GenerateExprResult {
    GenerateExprResult {
        generator: gen,
        code: var.name
    }
}

fn generate_binary_op(mut gen: CodeGenerator, op: HirBinaryOp) -> GenerateExprResult {
    let left_result = generate_expression(gen, op.left);
    gen = left_result.generator;
    
    let right_result = generate_expression(gen, op.right);
    gen = right_result.generator;
    
    let code = "(" + left_result.code + " " + generate_operator(op.operator) + " " + right_result.code + ")";
    
    GenerateExprResult {
        generator: gen,
        code: code
    }
}

fn generate_unary_op(mut gen: CodeGenerator, op: HirUnaryOp) -> GenerateExprResult {
    let result = generate_expression(gen, op.operand);
    let code = generate_operator(op.operator) + result.code;
    
    GenerateExprResult {
        generator: result.generator,
        code: code
    }
}

fn generate_call(mut gen: CodeGenerator, call: HirCall) -> GenerateExprResult {
    let mut code = call.function_name + "(";
    let mut first = true;
    
    for arg in call.arguments {
        if !first {
            code = code + ", ";
        }
        first = false;
        
        let result = generate_expression(gen, arg);
        gen = result.generator;
        code = code + result.code;
    }
    
    code = code + ")";
    
    GenerateExprResult {
        generator: gen,
        code: code
    }
}

fn generate_if(mut gen: CodeGenerator, if_expr: HirIf) -> GenerateExprResult {
    let mut code = "if (";
    
    let cond_result = generate_expression(gen, if_expr.condition);
    gen = cond_result.generator;
    code = code + cond_result.code + ") {\n";
    
    gen.context.indent_level = gen.context.indent_level + 1;
    let then_result = generate_block(gen, if_expr.then_block);
    gen = then_result.generator;
    code = code + then_result.code;
    gen.context.indent_level = gen.context.indent_level - 1;
    
    code = code + indent(gen.context.indent_level) + "}";
    
    if if_expr.else_block != empty_hir_block() {
        code = code + " else {\n";
        gen.context.indent_level = gen.context.indent_level + 1;
        let else_result = generate_block(gen, if_expr.else_block);
        gen = else_result.generator;
        code = code + else_result.code;
        gen.context.indent_level = gen.context.indent_level - 1;
        code = code + indent(gen.context.indent_level) + "}";
    }
    
    GenerateExprResult {
        generator: gen,
        code: code
    }
}

fn generate_while(mut gen: CodeGenerator, while_loop: HirWhile) -> GenerateExprResult {
    let mut code = "while (";
    
    let cond_result = generate_expression(gen, while_loop.condition);
    gen = cond_result.generator;
    code = code + cond_result.code + ") {\n";
    
    gen.context.indent_level = gen.context.indent_level + 1;
    let body_result = generate_block(gen, while_loop.body);
    gen = body_result.generator;
    code = code + body_result.code;
    gen.context.indent_level = gen.context.indent_level - 1;
    
    code = code + indent(gen.context.indent_level) + "}";
    
    GenerateExprResult {
        generator: gen,
        code: code
    }
}

fn generate_for(mut gen: CodeGenerator, for_loop: HirFor) -> GenerateExprResult {
    let mut code = "for (";
    code = code + for_loop.variable + " in ";
    
    let iter_result = generate_expression(gen, for_loop.iterator);
    gen = iter_result.generator;
    code = code + iter_result.code + ") {\n";
    
    gen.context.indent_level = gen.context.indent_level + 1;
    let body_result = generate_block(gen, for_loop.body);
    gen = body_result.generator;
    code = code + body_result.code;
    gen.context.indent_level = gen.context.indent_level - 1;
    
    code = code + indent(gen.context.indent_level) + "}";
    
    GenerateExprResult {
        generator: gen,
        code: code
    }
}

fn generate_match(mut gen: CodeGenerator, match_expr: HirMatch) -> GenerateExprResult {
    let mut code = "match (";
    
    let scrutinee_result = generate_expression(gen, match_expr.scrutinee);
    gen = scrutinee_result.generator;
    code = code + scrutinee_result.code + ") {\n";
    
    gen.context.indent_level = gen.context.indent_level + 1;
    
    for arm in match_expr.arms {
        code = code + indent(gen.context.indent_level);
        code = code + "/* pattern */ => {\n";
        
        gen.context.indent_level = gen.context.indent_level + 1;
        let body_result = generate_block(gen, arm.body);
        gen = body_result.generator;
        code = code + body_result.code;
        gen.context.indent_level = gen.context.indent_level - 1;
        
        code = code + indent(gen.context.indent_level) + "}\n";
    }
    
    gen.context.indent_level = gen.context.indent_level - 1;
    code = code + indent(gen.context.indent_level) + "}";
    
    GenerateExprResult {
        generator: gen,
        code: code
    }
}

fn generate_block_expr(mut gen: CodeGenerator, block: HirBlock) -> GenerateExprResult {
    let mut code = "{\n";
    gen.context.indent_level = gen.context.indent_level + 1;
    
    let result = generate_block(gen, block);
    gen = result.generator;
    code = code + result.code;
    
    gen.context.indent_level = gen.context.indent_level - 1;
    code = code + indent(gen.context.indent_level) + "}";
    
    GenerateExprResult {
        generator: gen,
        code: code
    }
}

fn generate_field_access(mut gen: CodeGenerator, access: HirFieldAccess) -> GenerateExprResult {
    let result = generate_expression(gen, access.object);
    let code = result.code + "." + access.field_name;
    
    GenerateExprResult {
        generator: result.generator,
        code: code
    }
}

fn generate_index_access(mut gen: CodeGenerator, access: HirIndexAccess) -> GenerateExprResult {
    let obj_result = generate_expression(gen, access.object);
    gen = obj_result.generator;
    
    let idx_result = generate_expression(gen, access.index);
    gen = idx_result.generator;
    
    let code = obj_result.code + "[" + idx_result.code + "]";
    
    GenerateExprResult {
        generator: gen,
        code: code
    }
}

fn generate_struct_lit(mut gen: CodeGenerator, lit: HirStructLit) -> GenerateExprResult {
    let mut code = lit.struct_name + " { ";
    let mut first = true;
    
    for field in lit.fields {
        if !first {
            code = code + ", ";
        }
        first = false;
        
        code = code + field.name + ": ";
        let result = generate_expression(gen, field.value);
        gen = result.generator;
        code = code + result.code;
    }
    
    code = code + " }";
    
    GenerateExprResult {
        generator: gen,
        code: code
    }
}

fn generate_array_lit(mut gen: CodeGenerator, lit: HirArrayLit) -> GenerateExprResult {
    let mut code = "[";
    let mut first = true;
    
    for element in lit.elements {
        if !first {
            code = code + ", ";
        }
        first = false;
        
        let result = generate_expression(gen, element);
        gen = result.generator;
        code = code + result.code;
    }
    
    code = code + "]";
    
    GenerateExprResult {
        generator: gen,
        code: code
    }
}

// ===== Type Generation =====

fn generate_type(type_id: i32) -> String {
    // Map type IDs to C type names
    if type_id == TYPE_I32 {
        "int32_t"
    } else if type_id == TYPE_I64 {
        "int64_t"
    } else if type_id == TYPE_U32 {
        "uint32_t"
    } else if type_id == TYPE_U64 {
        "uint64_t"
    } else if type_id == TYPE_F32 {
        "float"
    } else if type_id == TYPE_F64 {
        "double"
    } else if type_id == TYPE_BOOL {
        "bool"
    } else if type_id == TYPE_CHAR {
        "char"
    } else if type_id == TYPE_STRING {
        "char*"
    } else if type_id == TYPE_VOID {
        "void"
    } else {
        "void" // Unknown type
    }
}

// ===== Operator Generation =====

fn generate_operator(op: String) -> String {
    op // Operators are same in C and Aster for most cases
}

// ===== Utility Functions =====

fn indent(level: i32) -> String {
    let mut result = "";
    let mut i = 0;
    while i < level {
        result = result + "    "; // 4 spaces per indent
        i = i + 1;
    }
    result
}

fn emit(mut buffer: CodeBuffer, text: String) -> CodeBuffer {
    buffer.content = buffer.content + text;
    buffer
}

fn emit_line(mut buffer: CodeBuffer, line: String) -> CodeBuffer {
    buffer.content = buffer.content + line + "\n";
    buffer.line_count = buffer.line_count + 1;
    buffer
}

fn get_generated_code(buffer: CodeBuffer) -> String {
    buffer.content
}

fn add_codegen_error(mut gen: CodeGenerator, message: String) -> CodeGenerator {
    gen.errors.push(message);
    gen.error_count = gen.error_count + 1;
    gen
}

fn get_codegen_error_count(gen: CodeGenerator) -> i32 {
    gen.error_count
}

fn has_codegen_errors(gen: CodeGenerator) -> bool {
    gen.error_count > 0
}

fn code_buffer_append(mut buffer: CodeBuffer, text: String) -> CodeBuffer {
    buffer.content = buffer.content + text;
    buffer
}

fn code_buffer_clear(mut buffer: CodeBuffer) -> CodeBuffer {
    buffer.content = "";
    buffer.line_count = 0;
    buffer
}

fn dummy_code_buffer() -> CodeBuffer {
    new_code_buffer()
}

// Helper functions for type conversions
fn int_to_string(value: i32) -> String {
    "42" // Placeholder - would use actual conversion
}

fn float_to_string(value: f64) -> String {
    "3.14" // Placeholder - would use actual conversion
}

// Type ID constants (matching typecheck.ast)
const TYPE_I32: i32 = 1;
const TYPE_I64: i32 = 2;
const TYPE_U32: i32 = 3;
const TYPE_U64: i32 = 4;
const TYPE_F32: i32 = 5;
const TYPE_F64: i32 = 6;
const TYPE_BOOL: i32 = 7;
const TYPE_CHAR: i32 = 8;
const TYPE_STRING: i32 = 9;
const TYPE_VOID: i32 = 10;
