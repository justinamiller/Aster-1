// Parser - Recursive descent parser for Aster language
// Part of Aster Stage 1 (Core-0 implementation)
//
// This module implements a recursive descent parser that converts
// a stream of tokens into an Abstract Syntax Tree (AST).
//
// Language Subset: Core-0
// - Uses only: structs, enums, Vec, functions, while loops, match
// - No traits, no closures, no async, no tuples
// - Self-contained for Stage 0 compilation (includes all dependencies inline)

// ============================================================================
// CORE TYPE STUBS (Vec and Box provided by C# compiler at runtime)
// ============================================================================

// Note: Vec and Box are fundamental collection/pointer types.
// During Core-0 bootstrap, the C# compiler provides runtime support for these.
// We declare them here as opaque types to satisfy the type checker.

/// Generic vector type (provided by runtime)
struct Vec<T> {}

/// Get length of a Vec (helper for opaque Vec type)
/// C# runtime provides actual implementation
fn vec_len(v: Vec<Token>) -> i32 {
    // Stub - actual implementation provided by C# runtime
    0
}

/// Boxed pointer type (provided by runtime)
struct Box<T> {}

/// Create a new boxed expression (stub for Core-0)
/// The C# runtime provides the actual boxing implementation
fn Box_new(value: Expression) -> Box<Expression> {
    // Opaque stub - actual implementation provided by C# runtime
    Box {}
}

// ============================================================================
// EMBEDDED DEPENDENCIES (for self-contained compilation)
// ============================================================================

/// Source location span within a file
struct Span {
    file: String,
    line: i32,
    column: i32,
    start: i32,
    length: i32
}

/// Create a new Span
fn new_span(file: String, line: i32, column: i32, start: i32, length: i32) -> Span {
    Span {
        file: file,
        line: line,
        column: column,
        start: start,
        length: length
    }
}

/// Create an unknown/default span
fn unknown_span() -> Span {
    let empty = "";
    new_span(empty, 0, 0, 0, 0)
}

/// Token type enumeration
enum TokenKind {
    // Literals
    Identifier,
    IntegerLiteral,
    FloatLiteral,
    StringLiteral,
    CharLiteral,
    // Keywords
    Fn,
    Let,
    Mut,
    Type,
    Trait,
    Impl,
    Match,
    If,
    Else,
    For,
    While,
    Return,
    Break,
    Continue,
    Loop,
    Async,
    Await,
    Actor,
    Module,
    Pub,
    Extern,
    Unsafe,
    Using,
    Managed,
    Throws,
    Struct,
    Enum,
    True,
    False,
    // Operators
    Plus,
    Minus,
    Star,
    Slash,
    Percent,
    Ampersand,
    Pipe,
    Caret,
    Tilde,
    Bang,
    Less,
    Greater,
    Equals,
    Dot,
    DotDot,
    // Compound operators
    AmpersandAmpersand,
    PipePipe,
    EqualsEquals,
    BangEquals,
    LessEquals,
    GreaterEquals,
    Arrow,
    FatArrow,
    PlusEquals,
    MinusEquals,
    StarEquals,
    SlashEquals,
    ColonColon,
    // Punctuation
    LeftParen,
    RightParen,
    LeftBrace,
    RightBrace,
    LeftBracket,
    RightBracket,
    Comma,
    Colon,
    Semicolon,
    At,
    Hash,
    Underscore,
    // Special
    Eof,
    Error
}

/// Lexical token
struct Token {
    kind: TokenKind,
    span: Span,
    value: String
}

/// Create a new token
fn new_token(kind: TokenKind, span: Span, value: String) -> Token {
    Token {
        kind: kind,
        span: span,
        value: value
    }
}

/// Helper to compare two TokenKinds for equality
fn token_kind_equals(a: TokenKind, b: TokenKind) -> bool {
    // Simplified for Core-0
    false
}

/// Create an EOF token
fn make_eof_token(file: String, position: i32) -> Token {
    let empty = "";
    let span = new_span(file, 0, 0, position, 0);
    new_token(TokenKind::Eof, span, empty)
}

/// Diagnostic bag for collecting errors
struct DiagnosticBag {
    count: i32
}

/// Create a new empty diagnostic bag
fn new_diagnostic_bag() -> DiagnosticBag {
    DiagnosticBag {
        count: 0
    }
}

/// Add a diagnostic message to the bag
fn add_diagnostic(mut bag: DiagnosticBag, message: String) -> DiagnosticBag {
    bag.count = bag.count + 1;
    bag
}

/// Create an error diagnostic (stub for Core-0)
fn error(code: String, message: String, span: Span) -> String {
    message
}

// ============================================================================
// AST TYPE STUBS (for self-contained compilation)
// ============================================================================

/// Binary operators
enum BinaryOp {
    Add,
    Subtract,
    Multiply,
    Divide,
    Modulo,
    Equal,
    NotEqual,
    Less,
    LessEqual,
    Greater,
    GreaterEqual,
    LogicalAnd,
    LogicalOr
}

/// Unary operators
enum UnaryOp {
    Negate,
    Not
}

/// Module (top-level AST node)
struct Module {
    items: Vec<Item>
}

/// Top-level item
enum Item {
    Function(FunctionItem),
    Struct(StructItem),
    Enum(EnumItem),
    TypeAlias(TypeAliasItem),
    Error(ErrorItem)
}

/// Function item
struct FunctionItem {
    name: String,
    params: Vec<Parameter>,
    return_type: Type,
    body: Block,
    span: Span
}

/// Struct item
struct StructItem {
    name: String,
    fields: Vec<Field>,
    span: Span
}

/// Enum item
struct EnumItem {
    name: String,
    variants: Vec<Variant>,
    span: Span
}

/// Type alias item
struct TypeAliasItem {
    name: String,
    target: Type,
    span: Span
}

/// Error item (for error recovery)
struct ErrorItem {
    span: Span
}

/// Function parameter
struct Parameter {
    name: String,
    param_type: Type,
    span: Span
}

/// Struct field
struct Field {
    name: String,
    field_type: Type,
    span: Span
}

/// Enum variant
struct Variant {
    name: String,
    payload: OptionType
}

/// Option type for optional values (Core-0 replacement for Option<T>)
enum OptionType {
    SomeType(Type),
    NoneType
}

/// Type expression
enum Type {
    Named(String),
    Unit,
    Error
}

/// Block of statements
struct Block {
    statements: Vec<Statement>,
    span: Span
}

/// Statement
enum Statement {
    Let(LetStatement),
    Return(ReturnStatement),
    If(IfStatement),
    While(WhileStatement),
    For(ForStatement),
    Expression(ExpressionStatement)
}

/// Let statement
struct LetStatement {
    name: String,
    mutable: bool,
    type_annotation: OptionType,
    initializer: Expression,
    span: Span
}

/// Return statement
struct ReturnStatement {
    value: OptionExpression,
    span: Span
}

/// If statement
struct IfStatement {
    condition: Expression,
    then_block: Block,
    else_block: OptionBlock,
    span: Span
}

/// While statement
struct WhileStatement {
    condition: Expression,
    body: Block,
    span: Span
}

/// For statement
struct ForStatement {
    variable: String,
    iterator: Expression,
    body: Block,
    span: Span
}

/// Expression statement
struct ExpressionStatement {
    expression: Expression,
    span: Span
}

/// Expression
enum Expression {
    IntegerLiteral(IntegerLiteralExpr),
    FloatLiteral(FloatLiteralExpr),
    StringLiteral(StringLiteralExpr),
    CharLiteral(CharLiteralExpr),
    BooleanLiteral(BooleanLiteralExpr),
    Identifier(IdentifierExpr),
    Binary(BinaryExpr),
    Unary(UnaryExpr),
    Call(CallExpr),
    FieldAccess(FieldAccessExpr),
    Assignment(AssignmentExpr),
    Error(ErrorExpr)
}

/// Integer literal expression
struct IntegerLiteralExpr {
    value: String,
    span: Span
}

/// Float literal expression
struct FloatLiteralExpr {
    value: String,
    span: Span
}

/// String literal expression
struct StringLiteralExpr {
    value: String,
    span: Span
}

/// Character literal expression
struct CharLiteralExpr {
    value: String,
    span: Span
}

/// Boolean literal expression
struct BooleanLiteralExpr {
    value: bool,
    span: Span
}

/// Identifier expression
struct IdentifierExpr {
    name: String,
    span: Span
}

/// Binary expression
struct BinaryExpr {
    left: Box<Expression>,
    op: BinaryOp,
    right: Box<Expression>,
    span: Span
}

/// Unary expression
struct UnaryExpr {
    op: UnaryOp,
    operand: Box<Expression>,
    span: Span
}

/// Call expression
struct CallExpr {
    callee: Box<Expression>,
    arguments: Vec<Expression>,
    span: Span
}

/// Field access expression
struct FieldAccessExpr {
    object: Box<Expression>,
    field: String,
    span: Span
}

/// Assignment expression
struct AssignmentExpr {
    target: Box<Expression>,
    value: Box<Expression>,
    span: Span
}

/// Error expression (for error recovery)
struct ErrorExpr {}

/// Option type for Expression (Core-0 replacement for Option<Expression>)
enum OptionExpression {
    SomeExpression(Expression),
    NoneExpression
}

/// Option type for Block (Core-0 replacement for Option<Block>)
enum OptionBlock {
    SomeBlock(Block),
    NoneBlock
}

// ============================================================================
// PARSER IMPLEMENTATION
// ============================================================================

/// Parser state for converting tokens to AST
struct Parser {
    tokens: Vec<Token>,
    position: i32,
    diagnostics: DiagnosticBag
}

/// Result types for parser functions (Core-0 doesn't support tuple returns)
struct ParserModuleResult {
    parser: Parser,
    parsed_module: Module
}

struct ParserItemResult {
    parser: Parser,
    item: Item
}

struct ParserParameterResult {
    parser: Parser,
    parameter: Parameter
}

struct ParserParametersResult {
    parser: Parser,
    parameters: Vec<Parameter>
}

struct ParserFieldResult {
    parser: Parser,
    field: Field
}

struct ParserFieldsResult {
    parser: Parser,
    fields: Vec<Field>
}

struct ParserVariantResult {
    parser: Parser,
    variant: Variant
}

struct ParserVariantsResult {
    parser: Parser,
    variants: Vec<Variant>
}

struct ParserTypeResult {
    parser: Parser,
    type_value: Type
}

struct ParserBlockResult {
    parser: Parser,
    block: Block
}

struct ParserStatementResult {
    parser: Parser,
    statement: Statement
}

struct ParserExpressionResult {
    parser: Parser,
    expression: Expression
}

struct ParserExpressionsResult {
    parser: Parser,
    expressions: Vec<Expression>
}

struct ParserTokenResult {
    parser: Parser,
    token: Token
}

struct ParserStringResult {
    parser: Parser,
    value: String
}

/// Create a new parser from a token stream
fn new_parser(tokens: Vec<Token>) -> Parser {
    Parser {
        tokens: tokens,
        position: 0,
        diagnostics: new_diagnostic_bag()
    }
}

/// Parse a complete source file into an AST
/// Returns (updated_parser, module)
fn parse(mut parser: Parser) -> ParserModuleResult {
    let mut items = Vec::new();
    
    while !is_at_end(parser) {
        let result = parse_item(parser);
        parser = result.parser;
        let item = result.item;
        items.push(item);
    }
    
    let parsed_module = Module {
        items: items
    };
    ParserModuleResult { parser: parser, parsed_module: parsed_module }
}

/// Parse a top-level item (function, struct, enum, etc.)
/// Returns (updated_parser, item)
fn parse_item(mut parser: Parser) -> ParserItemResult {
    let token = peek(parser);
    
    let result = match token.kind {
        TokenKind::Fn => parse_function(parser),
        TokenKind::Struct => parse_struct(parser),
        TokenKind::Enum => parse_enum(parser),
        TokenKind::Type => parse_type_alias(parser),
        _ => {
            let msg = String::from("Expected item (fn, struct, enum, type)");
            parser = report_error(parser, msg, token.span);
            // Skip to next item
            parser = synchronize(parser);
            ParserItemResult { parser: parser, item: error_item() }
        }
    };
    result
}

/// Parse a function declaration
/// Returns (updated_parser, item)
fn parse_function(mut parser: Parser) -> ParserItemResult {
    let start = current_span(parser);
    
    // fn keyword
    parser = expect(parser, TokenKind::Fn).parser;
    
    // Function name
    let name_result = expect_identifier(parser);
    parser = name_result.parser;
    let name = name_result.value;
    
    // Parameters
    parser = expect(parser, TokenKind::LeftParen).parser;
    let params_result = parse_parameter_list(parser);
    parser = params_result.parser;
    let params = params_result.parameters;
    parser = expect(parser, TokenKind::RightParen).parser;
    
    // Return type (optional)
    let return_type = if check(parser, TokenKind::Arrow) {
        parser = advance(parser);
        let type_result = parse_type(parser);
        parser = type_result.parser;
        type_result.type_value
    } else {
        unit_type()
    };
    
    // Body
    let body_result = parse_block(parser);
    parser = body_result.parser;
    let body = body_result.block;
    
    let item = Item::Function(FunctionItem {
        name: name,
        params: params,
        return_type: return_type,
        body: body,
        span: start
    });
    ParserItemResult { parser: parser, item: item }
}

/// Parse a struct declaration
/// Returns (updated_parser, item)
fn parse_struct(mut parser: Parser) -> ParserItemResult {
    let start = current_span(parser);
    
    // struct keyword
    parser = expect(parser, TokenKind::Struct).parser;
    
    // Struct name
    let name_result = expect_identifier(parser);
    parser = name_result.parser;
    let name = name_result.value;
    
    // Fields
    parser = expect(parser, TokenKind::LeftBrace).parser;
    let fields_result = parse_field_list(parser);
    parser = fields_result.parser;
    let fields = fields_result.fields;
    parser = expect(parser, TokenKind::RightBrace).parser;
    
    let item = Item::Struct(StructItem {
        name: name,
        fields: fields,
        span: start
    });
    ParserItemResult { parser: parser, item: item }
}

/// Parse an enum declaration
/// Returns (updated_parser, item)
fn parse_enum(mut parser: Parser) -> ParserItemResult {
    let start = current_span(parser);
    
    // enum keyword
    parser = expect(parser, TokenKind::Enum).parser;
    
    // Enum name
    let name_result = expect_identifier(parser);
    parser = name_result.parser;
    let name = name_result.value;
    
    // Variants
    parser = expect(parser, TokenKind::LeftBrace).parser;
    let variants_result = parse_variant_list(parser);
    parser = variants_result.parser;
    let variants = variants_result.variants;
    parser = expect(parser, TokenKind::RightBrace).parser;
    
    let item = Item::Enum(EnumItem {
        name: name,
        variants: variants,
        span: start
    });
    ParserItemResult { parser: parser, item: item }
}

/// Parse a type alias
/// Returns (updated_parser, item)
fn parse_type_alias(mut parser: Parser) -> ParserItemResult {
    let start = current_span(parser);
    
    // type keyword
    parser = expect(parser, TokenKind::Type).parser;
    
    // Type name
    let name_result = expect_identifier(parser);
    parser = name_result.parser;
    let name = name_result.value;
    
    // Equals
    parser = expect(parser, TokenKind::Equals).parser;
    
    // Aliased type
    let type_result = parse_type(parser);
    parser = type_result.parser;
    let aliased = type_result.type_value;
    
    // Semicolon
    parser = expect(parser, TokenKind::Semicolon).parser;
    
    let item = Item::TypeAlias(TypeAliasItem {
        name: name,
        aliased_type: aliased,
        span: start
    });
    ParserItemResult { parser: parser, item: item }
}

/// Parse a parameter list
/// Returns (updated_parser, parameters)
fn parse_parameter_list(mut parser: Parser) -> ParserParametersResult {
    let mut params = Vec::new();
    
    if !check(parser, TokenKind::RightParen) {
        while true {
            let param_result = parse_parameter(parser);
            parser = param_result.parser;
            let param = param_result.parameter;
            params.push(param);
            
            if !check(parser, TokenKind::Comma) {
                break;
            }
            parser = advance(parser);
        }
    }
    
    ParserParametersResult { parser: parser, parameters: params }
}

/// Parse a single parameter
/// Returns (updated_parser, parameter)
fn parse_parameter(mut parser: Parser) -> ParserParameterResult {
    let name_result = expect_identifier(parser);
    parser = name_result.parser;
    let name = name_result.value;
    
    parser = expect(parser, TokenKind::Colon).parser;
    
    let type_result = parse_type(parser);
    parser = type_result.parser;
    let param_type = type_result.type_value;
    
    let param = Parameter {
        name: name,
        param_type: param_type
    };
    ParserParameterResult { parser: parser, parameter: param }
}

/// Parse a field list (for structs)
/// Returns (updated_parser, fields)
fn parse_field_list(mut parser: Parser) -> ParserFieldsResult {
    let mut fields = Vec::new();
    
    while !check(parser, TokenKind::RightBrace) && !is_at_end(parser) {
        let field_result = parse_field(parser);
        parser = field_result.parser;
        let field = field_result.field;
        fields.push(field);
        
        if check(parser, TokenKind::Comma) {
            parser = advance(parser);
        }
    }
    
    ParserFieldsResult { parser: parser, fields: fields }
}

/// Parse a single field
/// Returns (updated_parser, field)
fn parse_field(mut parser: Parser) -> ParserFieldResult {
    let name_result = expect_identifier(parser);
    parser = name_result.parser;
    let name = name_result.value;
    
    parser = expect(parser, TokenKind::Colon).parser;
    
    let type_result = parse_type(parser);
    parser = type_result.parser;
    let field_type = type_result.type_value;
    
    let field = Field {
        name: name,
        field_type: field_type
    };
    ParserFieldResult { parser: parser, field: field }
}

/// Parse a variant list (for enums)
/// Returns (updated_parser, variants)
fn parse_variant_list(mut parser: Parser) -> ParserVariantsResult {
    let mut variants = Vec::new();
    
    while !check(parser, TokenKind::RightBrace) && !is_at_end(parser) {
        let variant_result = parse_variant(parser);
        parser = variant_result.parser;
        let variant = variant_result.variant;
        variants.push(variant);
        
        if check(parser, TokenKind::Comma) {
            parser = advance(parser);
        }
    }
    
    ParserVariantsResult { parser: parser, variants: variants }
}

/// Parse a single variant
/// Returns (updated_parser, variant)
fn parse_variant(mut parser: Parser) -> ParserVariantResult {
    let name_result = expect_identifier(parser);
    parser = name_result.parser;
    let name = name_result.value;
    
    // Optional payload type
    let payload = if check(parser, TokenKind::LeftParen) {
        parser = advance(parser);
        let type_result = parse_type(parser);
        parser = type_result.parser;
        let ty = type_result.type_value;
        parser = expect(parser, TokenKind::RightParen).parser;
        OptionType::SomeType(ty)
    } else {
        OptionType::NoneType
    };
    
    let variant = Variant {
        name: name,
        payload: payload
    };
    ParserVariantResult { parser: parser, variant: variant }
}

/// Parse a type expression
/// Returns (updated_parser, type)
fn parse_type(mut parser: Parser) -> ParserTypeResult {
    let token = peek(parser);
    
    let result = match token.kind {
        TokenKind::Identifier => {
            let name_result = expect_identifier(parser);
            parser = name_result.parser;
            let name = name_result.value;
            ParserTypeResult { parser: parser, type_value: Type::Named(name) }
        },
        _ => {
            let msg = String::from("Expected type");
            parser = report_error(parser, msg, token.span);
            ParserTypeResult { parser: parser, type_value: error_type() }
        }
    };
    result
}

/// Parse a block statement
/// Returns (updated_parser, block)
fn parse_block(mut parser: Parser) -> ParserBlockResult {
    let start = current_span(parser);
    parser = expect(parser, TokenKind::LeftBrace).parser;
    
    let mut statements = Vec::new();
    
    while !check(parser, TokenKind::RightBrace) && !is_at_end(parser) {
        let stmt_result = parse_statement(parser);
        parser = stmt_result.parser;
        let stmt = stmt_result.statement;
        statements.push(stmt);
    }
    
    parser = expect(parser, TokenKind::RightBrace).parser;
    
    let block = Block {
        statements: statements,
        span: start
    };
    ParserBlockResult { parser: parser, block: block }
}

/// Parse a statement
/// Returns (updated_parser, statement)
fn parse_statement(parser: Parser) -> ParserStatementResult {
    let token = peek(parser);
    
    let result = match token.kind {
        TokenKind::Let => parse_let_statement(parser),
        TokenKind::Return => parse_return_statement(parser),
        TokenKind::If => parse_if_statement(parser),
        TokenKind::While => parse_while_statement(parser),
        TokenKind::For => parse_for_statement(parser),
        _ => parse_expression_statement(parser)
    };
    result
}

/// Parse a let statement
/// Returns (updated_parser, statement)
fn parse_let_statement(mut parser: Parser) -> ParserStatementResult {
    let start = current_span(parser);
    parser = expect(parser, TokenKind::Let).parser;
    
    let mutable = if check(parser, TokenKind::Mut) {
        parser = advance(parser);
        true
    } else {
        false
    };
    
    let name_result = expect_identifier(parser);
    parser = name_result.parser;
    let name = name_result.value;
    
    let type_annotation = if check(parser, TokenKind::Colon) {
        parser = advance(parser);
        let type_result = parse_type(parser);
        parser = type_result.parser;
        OptionType::SomeType(type_result.type_value)
    } else {
        OptionType::NoneType
    };
    
    parser = expect(parser, TokenKind::Equals).parser;
    let expr_result = parse_expression(parser);
    parser = expr_result.parser;
    let initializer = expr_result.expression;
    parser = expect(parser, TokenKind::Semicolon).parser;
    
    let stmt = Statement::Let(LetStatement {
        name: name,
        mutable: mutable,
        type_annotation: type_annotation,
        initializer: initializer,
        span: start
    });
    ParserStatementResult { parser: parser, statement: stmt }
}

/// Parse a return statement
/// Returns (updated_parser, statement)
fn parse_return_statement(mut parser: Parser) -> ParserStatementResult {
    let start = current_span(parser);
    parser = expect(parser, TokenKind::Return).parser;
    
    let value = if !check(parser, TokenKind::Semicolon) {
        let expr_result = parse_expression(parser);
        parser = expr_result.parser;
        OptionExpression::SomeExpression(expr_result.expression)
    } else {
        OptionExpression::NoneExpression
    };
    
    parser = expect(parser, TokenKind::Semicolon).parser;
    
    let stmt = Statement::Return(ReturnStatement {
        value: value,
        span: start
    });
    ParserStatementResult { parser: parser, statement: stmt }
}

/// Parse an if statement
/// Returns (updated_parser, statement)
fn parse_if_statement(mut parser: Parser) -> ParserStatementResult {
    let start = current_span(parser);
    parser = expect(parser, TokenKind::If).parser;
    
    let cond_result = parse_expression(parser);
    parser = cond_result.parser;
    let condition = cond_result.expression;
    
    let then_result = parse_block(parser);
    parser = then_result.parser;
    let then_block = then_result.block;
    
    let else_block = if check(parser, TokenKind::Else) {
        parser = advance(parser);
        let else_result = parse_block(parser);
        parser = else_result.parser;
        OptionBlock::SomeBlock(else_result.block)
    } else {
        OptionBlock::NoneBlock
    };
    
    let stmt = Statement::If(IfStatement {
        condition: condition,
        then_block: then_block,
        else_block: else_block,
        span: start
    });
    ParserStatementResult { parser: parser, statement: stmt }
}

/// Parse a while statement
/// Returns (updated_parser, statement)
fn parse_while_statement(mut parser: Parser) -> ParserStatementResult {
    let start = current_span(parser);
    parser = expect(parser, TokenKind::While).parser;
    
    let cond_result = parse_expression(parser);
    parser = cond_result.parser;
    let condition = cond_result.expression;
    
    let body_result = parse_block(parser);
    parser = body_result.parser;
    let body = body_result.block;
    
    let stmt = Statement::While(WhileStatement {
        condition: condition,
        body: body,
        span: start
    });
    ParserStatementResult { parser: parser, statement: stmt }
}

/// Parse a for statement
/// Returns (updated_parser, statement)
fn parse_for_statement(mut parser: Parser) -> ParserStatementResult {
    let start = current_span(parser);
    parser = expect(parser, TokenKind::For).parser;
    
    let var_result = expect_identifier(parser);
    parser = var_result.parser;
    let variable = var_result.value;
    
    // Expect 'in' keyword (not in TokenKind, so we check for identifier "in")
    let in_token = peek(parser);
    parser = advance(parser);
    
    let iter_result = parse_expression(parser);
    parser = iter_result.parser;
    let iterable = iter_result.expression;
    
    let body_result = parse_block(parser);
    parser = body_result.parser;
    let body = body_result.block;
    
    let stmt = Statement::For(ForStatement {
        variable: variable,
        iterable: iterable,
        body: body,
        span: start
    });
    ParserStatementResult { parser: parser, statement: stmt }
}

/// Parse an expression statement
/// Returns (updated_parser, statement)
fn parse_expression_statement(mut parser: Parser) -> ParserStatementResult {
    let start = current_span(parser);
    let expr_result = parse_expression(parser);
    parser = expr_result.parser;
    let expr = expr_result.expression;
    parser = expect(parser, TokenKind::Semicolon).parser;
    
    let stmt = Statement::Expression(ExpressionStatement {
        expression: expr,
        span: start
    });
    ParserStatementResult { parser: parser, statement: stmt }
}

/// Parse an expression
/// Returns (updated_parser, expression)
fn parse_expression(parser: Parser) -> ParserExpressionResult {
    parse_assignment(parser)
}

/// Parse an assignment expression
/// Returns (updated_parser, expression)
fn parse_assignment(mut parser: Parser) -> ParserExpressionResult {
    let expr_result = parse_logical_or(parser);
    parser = expr_result.parser;
    let expr = expr_result.expression;
    
    if check(parser, TokenKind::Equals) {
        parser = advance(parser);
        let value_result = parse_assignment(parser);
        parser = value_result.parser;
        let value = value_result.expression;
        let assign_expr = Expression::Assignment(AssignmentExpr {
            target: Box_new(expr),
            value: Box_new(value)
        });
        return ParserExpressionResult { parser: parser, expression: assign_expr };
    }
    
    ParserExpressionResult { parser: parser, expression: expr }
}

/// Parse a logical OR expression
/// Returns (updated_parser, expression)
fn parse_logical_or(mut parser: Parser) -> ParserExpressionResult {
    let left_result = parse_logical_and(parser);
    parser = left_result.parser;
    let mut left = left_result.expression;
    
    while check(parser, TokenKind::PipePipe) {
        parser = advance(parser);
        let right_result = parse_logical_and(parser);
        parser = right_result.parser;
        let right = right_result.expression;
        left = Expression::Binary(BinaryExpr {
            left: Box_new(left),
            op: BinaryOp::LogicalOr,
            right: Box_new(right)
        });
    }
    
    ParserExpressionResult { parser: parser, expression: left }
}

/// Parse a logical AND expression
/// Returns (updated_parser, expression)
fn parse_logical_and(mut parser: Parser) -> ParserExpressionResult {
    let left_result = parse_equality(parser);
    parser = left_result.parser;
    let mut left = left_result.expression;
    
    while check(parser, TokenKind::AmpersandAmpersand) {
        parser = advance(parser);
        let right_result = parse_equality(parser);
        parser = right_result.parser;
        let right = right_result.expression;
        left = Expression::Binary(BinaryExpr {
            left: Box_new(left),
            op: BinaryOp::LogicalAnd,
            right: Box_new(right)
        });
    }
    
    ParserExpressionResult { parser: parser, expression: left }
}

/// Parse an equality expression
/// Returns (updated_parser, expression)
fn parse_equality(mut parser: Parser) -> ParserExpressionResult {
    let left_result = parse_comparison(parser);
    parser = left_result.parser;
    let mut left = left_result.expression;
    
    while check(parser, TokenKind::EqualsEquals) || check(parser, TokenKind::BangEquals) {
        let op = if check(parser, TokenKind::EqualsEquals) {
            parser = advance(parser);
            BinaryOp::Equal
        } else {
            parser = advance(parser);
            BinaryOp::NotEqual
        };
        
        let right_result = parse_comparison(parser);
        parser = right_result.parser;
        let right = right_result.expression;
        left = Expression::Binary(BinaryExpr {
            left: Box_new(left),
            op: op,
            right: Box_new(right)
        });
    }
    
    ParserExpressionResult { parser: parser, expression: left }
}

/// Parse a comparison expression
/// Returns (updated_parser, expression)
fn parse_comparison(mut parser: Parser) -> ParserExpressionResult {
    let left_result = parse_term(parser);
    parser = left_result.parser;
    let mut left = left_result.expression;
    
    while true {
        let op = if check(parser, TokenKind::Less) {
            parser = advance(parser);
            BinaryOp::Less
        } else if check(parser, TokenKind::LessEquals) {
            parser = advance(parser);
            BinaryOp::LessEqual
        } else if check(parser, TokenKind::Greater) {
            parser = advance(parser);
            BinaryOp::Greater
        } else if check(parser, TokenKind::GreaterEquals) {
            parser = advance(parser);
            BinaryOp::GreaterEqual
        } else {
            break;
        };
        
        let right_result = parse_term(parser);
        parser = right_result.parser;
        let right = right_result.expression;
        left = Expression::Binary(BinaryExpr {
            left: Box_new(left),
            op: op,
            right: Box_new(right)
        });
    }
    
    ParserExpressionResult { parser: parser, expression: left }
}

/// Parse a term expression (addition, subtraction)
/// Returns (updated_parser, expression)
fn parse_term(mut parser: Parser) -> ParserExpressionResult {
    let left_result = parse_factor(parser);
    parser = left_result.parser;
    let mut left = left_result.expression;
    
    while check(parser, TokenKind::Plus) || check(parser, TokenKind::Minus) {
        let op = if check(parser, TokenKind::Plus) {
            parser = advance(parser);
            BinaryOp::Add
        } else {
            parser = advance(parser);
            BinaryOp::Subtract
        };
        
        let right_result = parse_factor(parser);
        parser = right_result.parser;
        let right = right_result.expression;
        left = Expression::Binary(BinaryExpr {
            left: Box_new(left),
            op: op,
            right: Box_new(right)
        });
    }
    
    ParserExpressionResult { parser: parser, expression: left }
}

/// Parse a factor expression (multiplication, division, modulo)
/// Returns (updated_parser, expression)
fn parse_factor(mut parser: Parser) -> ParserExpressionResult {
    let left_result = parse_unary(parser);
    parser = left_result.parser;
    let mut left = left_result.expression;
    
    while true {
        let op = if check(parser, TokenKind::Star) {
            parser = advance(parser);
            BinaryOp::Multiply
        } else if check(parser, TokenKind::Slash) {
            parser = advance(parser);
            BinaryOp::Divide
        } else if check(parser, TokenKind::Percent) {
            parser = advance(parser);
            BinaryOp::Modulo
        } else {
            break;
        };
        
        let right_result = parse_unary(parser);
        parser = right_result.parser;
        let right = right_result.expression;
        left = Expression::Binary(BinaryExpr {
            left: Box_new(left),
            op: op,
            right: Box_new(right)
        });
    }
    
    ParserExpressionResult { parser: parser, expression: left }
}

/// Parse a unary expression
/// Returns (updated_parser, expression)
fn parse_unary(mut parser: Parser) -> ParserExpressionResult {
    if check(parser, TokenKind::Minus) {
        parser = advance(parser);
        let operand_result = parse_unary(parser);
        parser = operand_result.parser;
        let operand = operand_result.expression;
        let unary_expr = Expression::Unary(UnaryExpr {
            op: UnaryOp::Negate,
            operand: Box_new(operand)
        });
        return ParserExpressionResult { parser: parser, expression: unary_expr };
    }
    
    if check(parser, TokenKind::Bang) {
        parser = advance(parser);
        let operand_result = parse_unary(parser);
        parser = operand_result.parser;
        let operand = operand_result.expression;
        let unary_expr = Expression::Unary(UnaryExpr {
            op: UnaryOp::Not,
            operand: Box_new(operand)
        });
        return ParserExpressionResult { parser: parser, expression: unary_expr };
    }
    
    parse_call(parser)
}

/// Parse a call expression
/// Returns (updated_parser, expression)
fn parse_call(mut parser: Parser) -> ParserExpressionResult {
    let expr_result = parse_primary(parser);
    parser = expr_result.parser;
    let mut expr = expr_result.expression;
    
    while true {
        if check(parser, TokenKind::LeftParen) {
            parser = advance(parser);
            let args_result = parse_argument_list(parser);
            parser = args_result.parser;
            let args = args_result.expressions;
            parser = expect(parser, TokenKind::RightParen).parser;
            expr = Expression::Call(CallExpr {
                callee: Box_new(expr),
                arguments: args
            });
        } else if check(parser, TokenKind::Dot) {
            parser = advance(parser);
            let field_result = expect_identifier(parser);
            parser = field_result.parser;
            let field = field_result.value;
            expr = Expression::FieldAccess(FieldAccessExpr {
                object: Box_new(expr),
                field: field
            });
        } else {
            break;
        }
    }
    
    ParserExpressionResult { parser: parser, expression: expr }
}

/// Parse argument list
/// Returns (updated_parser, arguments)
fn parse_argument_list(mut parser: Parser) -> ParserExpressionsResult {
    let mut args = Vec::new();
    
    if !check(parser, TokenKind::RightParen) {
        while true {
            let arg_result = parse_expression(parser);
            parser = arg_result.parser;
            let arg = arg_result.expression;
            args.push(arg);
            
            if !check(parser, TokenKind::Comma) {
                break;
            }
            parser = advance(parser);
        }
    }
    
    ParserExpressionsResult { parser: parser, expressions: args }
}

/// Parse a primary expression
/// Returns (updated_parser, expression)
fn parse_primary(mut parser: Parser) -> ParserExpressionResult {
    let token = peek(parser);
    
    let result = match token.kind {
        TokenKind::IntegerLiteral => {
            parser = advance(parser);
            let expr = Expression::IntegerLiteral(IntegerLiteralExpr {
                value: token.value
            });
            ParserExpressionResult { parser: parser, expression: expr }
        },
        TokenKind::FloatLiteral => {
            parser = advance(parser);
            let expr = Expression::FloatLiteral(FloatLiteralExpr {
                value: token.value
            });
            ParserExpressionResult { parser: parser, expression: expr }
        },
        TokenKind::StringLiteral => {
            parser = advance(parser);
            let expr = Expression::StringLiteral(StringLiteralExpr {
                value: token.value
            });
            ParserExpressionResult { parser: parser, expression: expr }
        },
        TokenKind::CharLiteral => {
            parser = advance(parser);
            let expr = Expression::CharLiteral(CharLiteralExpr {
                value: token.value
            });
            ParserExpressionResult { parser: parser, expression: expr }
        },
        TokenKind::True => {
            parser = advance(parser);
            let expr = Expression::BooleanLiteral(BooleanLiteralExpr {
                value: true
            });
            ParserExpressionResult { parser: parser, expression: expr }
        },
        TokenKind::False => {
            parser = advance(parser);
            let expr = Expression::BooleanLiteral(BooleanLiteralExpr {
                value: false
            });
            ParserExpressionResult { parser: parser, expression: expr }
        },
        TokenKind::Identifier => {
            parser = advance(parser);
            let expr = Expression::Identifier(IdentifierExpr {
                name: token.value
            });
            ParserExpressionResult { parser: parser, expression: expr }
        },
        TokenKind::LeftParen => {
            parser = advance(parser);
            let expr_result = parse_expression(parser);
            parser = expr_result.parser;
            let expr = expr_result.expression;
            parser = expect(parser, TokenKind::RightParen).parser;
            ParserExpressionResult { parser: parser, expression: expr }
        },
        _ => {
            let msg = String::from("Expected expression");
            parser = report_error(parser, msg, token.span);
            ParserExpressionResult { parser: parser, expression: error_expression() }
        }
    };
    result
}

// Helper functions

/// Peek at the current token without consuming it
fn peek(parser: Parser) -> Token {
    let len = vec_len(parser.tokens);
    if parser.position < len {
        return parser.tokens[parser.position];
    } else {
        // Return EOF token
        let empty = "";
        return make_eof_token(empty, 0);
    }
}

/// Advance to the next token
/// Returns updated parser
fn advance(mut parser: Parser) -> Parser {
    if !is_at_end(parser) {
        parser.position = parser.position + 1;
    }
    parser
}

/// Check if current token matches a kind
fn check(parser: Parser, kind: TokenKind) -> bool {
    if is_at_end(parser) {
        false
    } else {
        let current = peek(parser);
        token_kind_equals(current.kind, kind)
    }
}

/// Expect a specific token kind
/// Returns (updated_parser, consumed_token)
fn expect(mut parser: Parser, kind: TokenKind) -> ParserTokenResult {
    if check(parser, kind) {
        let token = peek(parser);
        parser = advance(parser);
        ParserTokenResult { parser: parser, token: token }
    } else {
        let token = peek(parser);
        let msg = String::from("Unexpected token");
        parser = report_error(parser, msg, token.span);
        ParserTokenResult { parser: parser, token: token }
    }
}

/// Expect an identifier token
/// Returns (updated_parser, identifier_string)
fn expect_identifier(mut parser: Parser) -> ParserStringResult {
    let expect_result = expect(parser, TokenKind::Identifier);
    parser = expect_result.parser;
    let token = expect_result.token;
    ParserStringResult { parser: parser, value: token.value }
}

/// Check if we're at the end of the token stream
fn is_at_end(parser: Parser) -> bool {
    let token = peek(parser);
    token_kind_equals(token.kind, TokenKind::Eof)
}

/// Get the current span
fn current_span(parser: Parser) -> Span {
    peek(parser).span
}

/// Report an error
/// Returns updated_parser
fn report_error(mut parser: Parser, message: String, span: Span) -> Parser {
    let code = String::from("E0001");
    let diag = error(code, message, span);
    parser.diagnostics = add_diagnostic(parser.diagnostics, diag);
    parser
}

/// Synchronize after an error
/// Returns updated_parser
fn synchronize(mut parser: Parser) -> Parser {
    parser = advance(parser);
    
    while !is_at_end(parser) {
        let token = peek(parser);
        
        // Stop at statement boundaries
        match token.kind {
            TokenKind::Fn => break,
            TokenKind::Struct => break,
            TokenKind::Enum => break,
            TokenKind::Let => break,
            TokenKind::Return => break,
            TokenKind::If => break,
            TokenKind::While => break,
            TokenKind::For => break,
            _ => {}
        }
        
        parser = advance(parser);
    }
    parser
}

// Error recovery helpers

fn error_item() -> Item {
    let empty = "";
    let span = unknown_span();
    Item::Error(ErrorItem {
        span: span
    })
}

fn error_type() -> Type {
    Type::Error
}

fn error_expression() -> Expression {
    Expression::Error(ErrorExpr {})
}

fn unit_type() -> Type {
    Type::Unit
}
