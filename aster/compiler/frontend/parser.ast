// Parser - Recursive descent parser for Aster language
// Part of Aster Stage 1 (Core-0 implementation)
//
// This module implements a recursive descent parser that converts
// a stream of tokens into an Abstract Syntax Tree (AST).
//
// Language Subset: Core-0
// - Uses only: structs, enums, Vec, functions, while loops, match
// - No traits, no closures, no async

/// Parser state for converting tokens to AST
struct Parser {
    tokens: Vec<Token>,
    position: i32,
    diagnostics: DiagnosticBag
}

/// Create a new parser from a token stream
fn new_parser(tokens: Vec<Token>) -> Parser {
    Parser {
        tokens: tokens,
        position: 0,
        diagnostics: new_diagnostic_bag()
    }
}

/// Parse a complete source file into an AST
/// Returns (updated_parser, module)
fn parse(mut parser: Parser) -> (Parser, Module) {
    let mut items = Vec::new();
    
    while !is_at_end(parser.clone()) {
        let result = parse_item(parser);
        parser = result.0;
        let item = result.1;
        items.push(item);
    }
    
    let module = Module {
        items: items
    };
    (parser, module)
}

/// Parse a top-level item (function, struct, enum, etc.)
/// Returns (updated_parser, item)
fn parse_item(mut parser: Parser) -> (Parser, Item) {
    let token = peek(parser.clone());
    
    match token.kind {
        TokenKind::Fn => parse_function(parser),
        TokenKind::Struct => parse_struct(parser),
        TokenKind::Enum => parse_enum(parser),
        TokenKind::Type => parse_type_alias(parser),
        _ => {
            let msg = String::from("Expected item (fn, struct, enum, type)");
            parser = report_error(parser, msg, token.span);
            // Skip to next item
            parser = synchronize(parser);
            (parser, error_item())
        }
    }
}

/// Parse a function declaration
/// Returns (updated_parser, item)
fn parse_function(mut parser: Parser) -> (Parser, Item) {
    let start = current_span(parser.clone());
    
    // fn keyword
    parser = expect(parser, TokenKind::Fn).0;
    
    // Function name
    let name_result = expect_identifier(parser);
    parser = name_result.0;
    let name = name_result.1;
    
    // Parameters
    parser = expect(parser, TokenKind::LeftParen).0;
    let params_result = parse_parameter_list(parser);
    parser = params_result.0;
    let params = params_result.1;
    parser = expect(parser, TokenKind::RightParen).0;
    
    // Return type (optional)
    let return_type = if check(parser.clone(), TokenKind::Arrow) {
        parser = advance(parser);
        let type_result = parse_type(parser);
        parser = type_result.0;
        type_result.1
    } else {
        unit_type()
    };
    
    // Body
    let body_result = parse_block(parser);
    parser = body_result.0;
    let body = body_result.1;
    
    let item = Item::Function(FunctionItem {
        name: name,
        params: params,
        return_type: return_type,
        body: body,
        span: start
    });
    (parser, item)
}

/// Parse a struct declaration
/// Returns (updated_parser, item)
fn parse_struct(mut parser: Parser) -> (Parser, Item) {
    let start = current_span(parser.clone());
    
    // struct keyword
    parser = expect(parser, TokenKind::Struct).0;
    
    // Struct name
    let name_result = expect_identifier(parser);
    parser = name_result.0;
    let name = name_result.1;
    
    // Fields
    parser = expect(parser, TokenKind::LeftBrace).0;
    let fields_result = parse_field_list(parser);
    parser = fields_result.0;
    let fields = fields_result.1;
    parser = expect(parser, TokenKind::RightBrace).0;
    
    let item = Item::Struct(StructItem {
        name: name,
        fields: fields,
        span: start
    });
    (parser, item)
}

/// Parse an enum declaration
/// Returns (updated_parser, item)
fn parse_enum(mut parser: Parser) -> (Parser, Item) {
    let start = current_span(parser.clone());
    
    // enum keyword
    parser = expect(parser, TokenKind::Enum).0;
    
    // Enum name
    let name_result = expect_identifier(parser);
    parser = name_result.0;
    let name = name_result.1;
    
    // Variants
    parser = expect(parser, TokenKind::LeftBrace).0;
    let variants_result = parse_variant_list(parser);
    parser = variants_result.0;
    let variants = variants_result.1;
    parser = expect(parser, TokenKind::RightBrace).0;
    
    let item = Item::Enum(EnumItem {
        name: name,
        variants: variants,
        span: start
    });
    (parser, item)
}

/// Parse a type alias
/// Returns (updated_parser, item)
fn parse_type_alias(mut parser: Parser) -> (Parser, Item) {
    let start = current_span(parser.clone());
    
    // type keyword
    parser = expect(parser, TokenKind::Type).0;
    
    // Type name
    let name_result = expect_identifier(parser);
    parser = name_result.0;
    let name = name_result.1;
    
    // Equals
    parser = expect(parser, TokenKind::Equals).0;
    
    // Aliased type
    let type_result = parse_type(parser);
    parser = type_result.0;
    let aliased = type_result.1;
    
    // Semicolon
    parser = expect(parser, TokenKind::Semicolon).0;
    
    let item = Item::TypeAlias(TypeAliasItem {
        name: name,
        aliased_type: aliased,
        span: start
    });
    (parser, item)
}

/// Parse a parameter list
/// Returns (updated_parser, parameters)
fn parse_parameter_list(mut parser: Parser) -> (Parser, Vec<Parameter>) {
    let mut params = Vec::new();
    
    if !check(parser.clone(), TokenKind::RightParen) {
        loop {
            let param_result = parse_parameter(parser);
            parser = param_result.0;
            let param = param_result.1;
            params.push(param);
            
            if !check(parser.clone(), TokenKind::Comma) {
                break;
            }
            parser = advance(parser);
        }
    }
    
    (parser, params)
}

/// Parse a single parameter
/// Returns (updated_parser, parameter)
fn parse_parameter(mut parser: Parser) -> (Parser, Parameter) {
    let name_result = expect_identifier(parser);
    parser = name_result.0;
    let name = name_result.1;
    
    parser = expect(parser, TokenKind::Colon).0;
    
    let type_result = parse_type(parser);
    parser = type_result.0;
    let param_type = type_result.1;
    
    let param = Parameter {
        name: name,
        param_type: param_type
    };
    (parser, param)
}

/// Parse a field list (for structs)
/// Returns (updated_parser, fields)
fn parse_field_list(mut parser: Parser) -> (Parser, Vec<Field>) {
    let mut fields = Vec::new();
    
    while !check(parser.clone(), TokenKind::RightBrace) && !is_at_end(parser.clone()) {
        let field_result = parse_field(parser);
        parser = field_result.0;
        let field = field_result.1;
        fields.push(field);
        
        if check(parser.clone(), TokenKind::Comma) {
            parser = advance(parser);
        }
    }
    
    (parser, fields)
}

/// Parse a single field
/// Returns (updated_parser, field)
fn parse_field(mut parser: Parser) -> (Parser, Field) {
    let name_result = expect_identifier(parser);
    parser = name_result.0;
    let name = name_result.1;
    
    parser = expect(parser, TokenKind::Colon).0;
    
    let type_result = parse_type(parser);
    parser = type_result.0;
    let field_type = type_result.1;
    
    let field = Field {
        name: name,
        field_type: field_type
    };
    (parser, field)
}

/// Parse a variant list (for enums)
/// Returns (updated_parser, variants)
fn parse_variant_list(mut parser: Parser) -> (Parser, Vec<Variant>) {
    let mut variants = Vec::new();
    
    while !check(parser.clone(), TokenKind::RightBrace) && !is_at_end(parser.clone()) {
        let variant_result = parse_variant(parser);
        parser = variant_result.0;
        let variant = variant_result.1;
        variants.push(variant);
        
        if check(parser.clone(), TokenKind::Comma) {
            parser = advance(parser);
        }
    }
    
    (parser, variants)
}

/// Parse a single variant
/// Returns (updated_parser, variant)
fn parse_variant(mut parser: Parser) -> (Parser, Variant) {
    let name_result = expect_identifier(parser);
    parser = name_result.0;
    let name = name_result.1;
    
    // Optional payload type
    let payload = if check(parser.clone(), TokenKind::LeftParen) {
        parser = advance(parser);
        let type_result = parse_type(parser);
        parser = type_result.0;
        let ty = type_result.1;
        parser = expect(parser, TokenKind::RightParen).0;
        Some(ty)
    } else {
        None
    };
    
    let variant = Variant {
        name: name,
        payload: payload
    };
    (parser, variant)
}

/// Parse a type expression
/// Returns (updated_parser, type)
fn parse_type(mut parser: Parser) -> (Parser, Type) {
    let token = peek(parser.clone());
    
    match token.kind {
        TokenKind::Identifier => {
            let name_result = expect_identifier(parser);
            parser = name_result.0;
            let name = name_result.1;
            (parser, Type::Named(name))
        },
        _ => {
            let msg = String::from("Expected type");
            parser = report_error(parser, msg, token.span);
            (parser, error_type())
        }
    }
}

/// Parse a block statement
/// Returns (updated_parser, block)
fn parse_block(mut parser: Parser) -> (Parser, Block) {
    let start = current_span(parser.clone());
    parser = expect(parser, TokenKind::LeftBrace).0;
    
    let mut statements = Vec::new();
    
    while !check(parser.clone(), TokenKind::RightBrace) && !is_at_end(parser.clone()) {
        let stmt_result = parse_statement(parser);
        parser = stmt_result.0;
        let stmt = stmt_result.1;
        statements.push(stmt);
    }
    
    parser = expect(parser, TokenKind::RightBrace).0;
    
    let block = Block {
        statements: statements,
        span: start
    };
    (parser, block)
}

/// Parse a statement
/// Returns (updated_parser, statement)
fn parse_statement(parser: Parser) -> (Parser, Statement) {
    let token = peek(parser.clone());
    
    match token.kind {
        TokenKind::Let => parse_let_statement(parser),
        TokenKind::Return => parse_return_statement(parser),
        TokenKind::If => parse_if_statement(parser),
        TokenKind::While => parse_while_statement(parser),
        TokenKind::For => parse_for_statement(parser),
        _ => parse_expression_statement(parser)
    }
}

/// Parse a let statement
/// Returns (updated_parser, statement)
fn parse_let_statement(mut parser: Parser) -> (Parser, Statement) {
    let start = current_span(parser.clone());
    parser = expect(parser, TokenKind::Let).0;
    
    let mutable = if check(parser.clone(), TokenKind::Mut) {
        parser = advance(parser);
        true
    } else {
        false
    };
    
    let name_result = expect_identifier(parser);
    parser = name_result.0;
    let name = name_result.1;
    
    let type_annotation = if check(parser.clone(), TokenKind::Colon) {
        parser = advance(parser);
        let type_result = parse_type(parser);
        parser = type_result.0;
        Some(type_result.1)
    } else {
        None
    };
    
    parser = expect(parser, TokenKind::Equals).0;
    let expr_result = parse_expression(parser);
    parser = expr_result.0;
    let initializer = expr_result.1;
    parser = expect(parser, TokenKind::Semicolon).0;
    
    let stmt = Statement::Let(LetStatement {
        name: name,
        mutable: mutable,
        type_annotation: type_annotation,
        initializer: initializer,
        span: start
    });
    (parser, stmt)
}

/// Parse a return statement
/// Returns (updated_parser, statement)
fn parse_return_statement(mut parser: Parser) -> (Parser, Statement) {
    let start = current_span(parser.clone());
    parser = expect(parser, TokenKind::Return).0;
    
    let value = if !check(parser.clone(), TokenKind::Semicolon) {
        let expr_result = parse_expression(parser);
        parser = expr_result.0;
        Some(expr_result.1)
    } else {
        None
    };
    
    parser = expect(parser, TokenKind::Semicolon).0;
    
    let stmt = Statement::Return(ReturnStatement {
        value: value,
        span: start
    });
    (parser, stmt)
}

/// Parse an if statement
/// Returns (updated_parser, statement)
fn parse_if_statement(mut parser: Parser) -> (Parser, Statement) {
    let start = current_span(parser.clone());
    parser = expect(parser, TokenKind::If).0;
    
    let cond_result = parse_expression(parser);
    parser = cond_result.0;
    let condition = cond_result.1;
    
    let then_result = parse_block(parser);
    parser = then_result.0;
    let then_block = then_result.1;
    
    let else_block = if check(parser.clone(), TokenKind::Else) {
        parser = advance(parser);
        let else_result = parse_block(parser);
        parser = else_result.0;
        Some(else_result.1)
    } else {
        None
    };
    
    let stmt = Statement::If(IfStatement {
        condition: condition,
        then_block: then_block,
        else_block: else_block,
        span: start
    });
    (parser, stmt)
}

/// Parse a while statement
/// Returns (updated_parser, statement)
fn parse_while_statement(mut parser: Parser) -> (Parser, Statement) {
    let start = current_span(parser.clone());
    parser = expect(parser, TokenKind::While).0;
    
    let cond_result = parse_expression(parser);
    parser = cond_result.0;
    let condition = cond_result.1;
    
    let body_result = parse_block(parser);
    parser = body_result.0;
    let body = body_result.1;
    
    let stmt = Statement::While(WhileStatement {
        condition: condition,
        body: body,
        span: start
    });
    (parser, stmt)
}

/// Parse a for statement
/// Returns (updated_parser, statement)
fn parse_for_statement(mut parser: Parser) -> (Parser, Statement) {
    let start = current_span(parser.clone());
    parser = expect(parser, TokenKind::For).0;
    
    let var_result = expect_identifier(parser);
    parser = var_result.0;
    let variable = var_result.1;
    
    // Expect 'in' keyword (not in TokenKind, so we check for identifier "in")
    let in_token = peek(parser.clone());
    parser = advance(parser);
    
    let iter_result = parse_expression(parser);
    parser = iter_result.0;
    let iterable = iter_result.1;
    
    let body_result = parse_block(parser);
    parser = body_result.0;
    let body = body_result.1;
    
    let stmt = Statement::For(ForStatement {
        variable: variable,
        iterable: iterable,
        body: body,
        span: start
    });
    (parser, stmt)
}

/// Parse an expression statement
/// Returns (updated_parser, statement)
fn parse_expression_statement(mut parser: Parser) -> (Parser, Statement) {
    let start = current_span(parser.clone());
    let expr_result = parse_expression(parser);
    parser = expr_result.0;
    let expr = expr_result.1;
    parser = expect(parser, TokenKind::Semicolon).0;
    
    let stmt = Statement::Expression(ExpressionStatement {
        expression: expr,
        span: start
    });
    (parser, stmt)
}

/// Parse an expression
/// Returns (updated_parser, expression)
fn parse_expression(parser: Parser) -> (Parser, Expression) {
    parse_assignment(parser)
}

/// Parse an assignment expression
/// Returns (updated_parser, expression)
fn parse_assignment(mut parser: Parser) -> (Parser, Expression) {
    let expr_result = parse_logical_or(parser);
    parser = expr_result.0;
    let expr = expr_result.1;
    
    if check(parser.clone(), TokenKind::Equals) {
        parser = advance(parser);
        let value_result = parse_assignment(parser);
        parser = value_result.0;
        let value = value_result.1;
        let assign_expr = Expression::Assignment(AssignmentExpr {
            target: Box::new(expr),
            value: Box::new(value)
        });
        return (parser, assign_expr);
    }
    
    (parser, expr)
}

/// Parse a logical OR expression
/// Returns (updated_parser, expression)
fn parse_logical_or(mut parser: Parser) -> (Parser, Expression) {
    let left_result = parse_logical_and(parser);
    parser = left_result.0;
    let mut left = left_result.1;
    
    while check(parser.clone(), TokenKind::PipePipe) {
        parser = advance(parser);
        let right_result = parse_logical_and(parser);
        parser = right_result.0;
        let right = right_result.1;
        left = Expression::Binary(BinaryExpr {
            left: Box::new(left),
            op: BinaryOp::LogicalOr,
            right: Box::new(right)
        });
    }
    
    (parser, left)
}

/// Parse a logical AND expression
/// Returns (updated_parser, expression)
fn parse_logical_and(mut parser: Parser) -> (Parser, Expression) {
    let left_result = parse_equality(parser);
    parser = left_result.0;
    let mut left = left_result.1;
    
    while check(parser.clone(), TokenKind::AmpersandAmpersand) {
        parser = advance(parser);
        let right_result = parse_equality(parser);
        parser = right_result.0;
        let right = right_result.1;
        left = Expression::Binary(BinaryExpr {
            left: Box::new(left),
            op: BinaryOp::LogicalAnd,
            right: Box::new(right)
        });
    }
    
    (parser, left)
}

/// Parse an equality expression
/// Returns (updated_parser, expression)
fn parse_equality(mut parser: Parser) -> (Parser, Expression) {
    let left_result = parse_comparison(parser);
    parser = left_result.0;
    let mut left = left_result.1;
    
    while check(parser.clone(), TokenKind::EqualsEquals) || check(parser.clone(), TokenKind::BangEquals) {
        let op = if check(parser.clone(), TokenKind::EqualsEquals) {
            parser = advance(parser);
            BinaryOp::Equal
        } else {
            parser = advance(parser);
            BinaryOp::NotEqual
        };
        
        let right_result = parse_comparison(parser);
        parser = right_result.0;
        let right = right_result.1;
        left = Expression::Binary(BinaryExpr {
            left: Box::new(left),
            op: op,
            right: Box::new(right)
        });
    }
    
    (parser, left)
}

/// Parse a comparison expression
/// Returns (updated_parser, expression)
fn parse_comparison(mut parser: Parser) -> (Parser, Expression) {
    let left_result = parse_term(parser);
    parser = left_result.0;
    let mut left = left_result.1;
    
    loop {
        let op = if check(parser.clone(), TokenKind::Less) {
            parser = advance(parser);
            BinaryOp::Less
        } else if check(parser.clone(), TokenKind::LessEquals) {
            parser = advance(parser);
            BinaryOp::LessEqual
        } else if check(parser.clone(), TokenKind::Greater) {
            parser = advance(parser);
            BinaryOp::Greater
        } else if check(parser.clone(), TokenKind::GreaterEquals) {
            parser = advance(parser);
            BinaryOp::GreaterEqual
        } else {
            break;
        };
        
        let right_result = parse_term(parser);
        parser = right_result.0;
        let right = right_result.1;
        left = Expression::Binary(BinaryExpr {
            left: Box::new(left),
            op: op,
            right: Box::new(right)
        });
    }
    
    (parser, left)
}

/// Parse a term expression (addition, subtraction)
/// Returns (updated_parser, expression)
fn parse_term(mut parser: Parser) -> (Parser, Expression) {
    let left_result = parse_factor(parser);
    parser = left_result.0;
    let mut left = left_result.1;
    
    while check(parser.clone(), TokenKind::Plus) || check(parser.clone(), TokenKind::Minus) {
        let op = if check(parser.clone(), TokenKind::Plus) {
            parser = advance(parser);
            BinaryOp::Add
        } else {
            parser = advance(parser);
            BinaryOp::Subtract
        };
        
        let right_result = parse_factor(parser);
        parser = right_result.0;
        let right = right_result.1;
        left = Expression::Binary(BinaryExpr {
            left: Box::new(left),
            op: op,
            right: Box::new(right)
        });
    }
    
    (parser, left)
}

/// Parse a factor expression (multiplication, division, modulo)
/// Returns (updated_parser, expression)
fn parse_factor(mut parser: Parser) -> (Parser, Expression) {
    let left_result = parse_unary(parser);
    parser = left_result.0;
    let mut left = left_result.1;
    
    loop {
        let op = if check(parser.clone(), TokenKind::Star) {
            parser = advance(parser);
            BinaryOp::Multiply
        } else if check(parser.clone(), TokenKind::Slash) {
            parser = advance(parser);
            BinaryOp::Divide
        } else if check(parser.clone(), TokenKind::Percent) {
            parser = advance(parser);
            BinaryOp::Modulo
        } else {
            break;
        };
        
        let right_result = parse_unary(parser);
        parser = right_result.0;
        let right = right_result.1;
        left = Expression::Binary(BinaryExpr {
            left: Box::new(left),
            op: op,
            right: Box::new(right)
        });
    }
    
    (parser, left)
}

/// Parse a unary expression
/// Returns (updated_parser, expression)
fn parse_unary(mut parser: Parser) -> (Parser, Expression) {
    if check(parser.clone(), TokenKind::Minus) {
        parser = advance(parser);
        let operand_result = parse_unary(parser);
        parser = operand_result.0;
        let operand = operand_result.1;
        let unary_expr = Expression::Unary(UnaryExpr {
            op: UnaryOp::Negate,
            operand: Box::new(operand)
        });
        return (parser, unary_expr);
    }
    
    if check(parser.clone(), TokenKind::Bang) {
        parser = advance(parser);
        let operand_result = parse_unary(parser);
        parser = operand_result.0;
        let operand = operand_result.1;
        let unary_expr = Expression::Unary(UnaryExpr {
            op: UnaryOp::Not,
            operand: Box::new(operand)
        });
        return (parser, unary_expr);
    }
    
    parse_call(parser)
}

/// Parse a call expression
/// Returns (updated_parser, expression)
fn parse_call(mut parser: Parser) -> (Parser, Expression) {
    let expr_result = parse_primary(parser);
    parser = expr_result.0;
    let mut expr = expr_result.1;
    
    loop {
        if check(parser.clone(), TokenKind::LeftParen) {
            parser = advance(parser);
            let args_result = parse_argument_list(parser);
            parser = args_result.0;
            let args = args_result.1;
            parser = expect(parser, TokenKind::RightParen).0;
            expr = Expression::Call(CallExpr {
                callee: Box::new(expr),
                arguments: args
            });
        } else if check(parser.clone(), TokenKind::Dot) {
            parser = advance(parser);
            let field_result = expect_identifier(parser);
            parser = field_result.0;
            let field = field_result.1;
            expr = Expression::FieldAccess(FieldAccessExpr {
                object: Box::new(expr),
                field: field
            });
        } else {
            break;
        }
    }
    
    (parser, expr)
}

/// Parse argument list
/// Returns (updated_parser, arguments)
fn parse_argument_list(mut parser: Parser) -> (Parser, Vec<Expression>) {
    let mut args = Vec::new();
    
    if !check(parser.clone(), TokenKind::RightParen) {
        loop {
            let arg_result = parse_expression(parser);
            parser = arg_result.0;
            let arg = arg_result.1;
            args.push(arg);
            
            if !check(parser.clone(), TokenKind::Comma) {
                break;
            }
            parser = advance(parser);
        }
    }
    
    (parser, args)
}

/// Parse a primary expression
/// Returns (updated_parser, expression)
fn parse_primary(mut parser: Parser) -> (Parser, Expression) {
    let token = peek(parser.clone());
    
    match token.kind {
        TokenKind::IntegerLiteral => {
            parser = advance(parser);
            let expr = Expression::IntegerLiteral(IntegerLiteralExpr {
                value: token.value
            });
            (parser, expr)
        },
        TokenKind::FloatLiteral => {
            parser = advance(parser);
            let expr = Expression::FloatLiteral(FloatLiteralExpr {
                value: token.value
            });
            (parser, expr)
        },
        TokenKind::StringLiteral => {
            parser = advance(parser);
            let expr = Expression::StringLiteral(StringLiteralExpr {
                value: token.value
            });
            (parser, expr)
        },
        TokenKind::CharLiteral => {
            parser = advance(parser);
            let expr = Expression::CharLiteral(CharLiteralExpr {
                value: token.value
            });
            (parser, expr)
        },
        TokenKind::True => {
            parser = advance(parser);
            let expr = Expression::BooleanLiteral(BooleanLiteralExpr {
                value: true
            });
            (parser, expr)
        },
        TokenKind::False => {
            parser = advance(parser);
            let expr = Expression::BooleanLiteral(BooleanLiteralExpr {
                value: false
            });
            (parser, expr)
        },
        TokenKind::Identifier => {
            parser = advance(parser);
            let expr = Expression::Identifier(IdentifierExpr {
                name: token.value
            });
            (parser, expr)
        },
        TokenKind::LeftParen => {
            parser = advance(parser);
            let expr_result = parse_expression(parser);
            parser = expr_result.0;
            let expr = expr_result.1;
            parser = expect(parser, TokenKind::RightParen).0;
            (parser, expr)
        },
        _ => {
            let msg = String::from("Expected expression");
            parser = report_error(parser, msg, token.span);
            (parser, error_expression())
        }
    }
}

// Helper functions

/// Peek at the current token without consuming it
fn peek(parser: Parser) -> Token {
    let pos_usize = i32_to_usize(parser.position);
    let len_i32 = usize_to_i32(parser.tokens.len());
    if parser.position < len_i32 {
        parser.tokens[pos_usize].clone()
    } else {
        // Return EOF token
        let empty = "";
        make_eof_token(empty, 0)
    }
}

/// Advance to the next token
/// Returns (updated_parser, consumed_token)
fn advance(mut parser: Parser) -> Parser {
    let token = peek(parser.clone());
    if !is_at_end(parser.clone()) {
        parser.position = parser.position + 1;
    }
    parser
}

/// Check if current token matches a kind
fn check(parser: Parser, kind: TokenKind) -> bool {
    if is_at_end(parser.clone()) {
        false
    } else {
        let current = peek(parser);
        token_kind_equals(current.kind, kind)
    }
}

/// Expect a specific token kind
/// Returns (updated_parser, consumed_token)
fn expect(mut parser: Parser, kind: TokenKind) -> (Parser, Token) {
    if check(parser.clone(), kind) {
        let token = peek(parser.clone());
        parser = advance(parser);
        (parser, token)
    } else {
        let token = peek(parser.clone());
        let msg = String::from("Unexpected token");
        parser = report_error(parser, msg, token.span);
        (parser, token)
    }
}

/// Expect an identifier token
/// Returns (updated_parser, identifier_string)
fn expect_identifier(mut parser: Parser) -> (Parser, String) {
    let expect_result = expect(parser, TokenKind::Identifier);
    parser = expect_result.0;
    let token = expect_result.1;
    (parser, token.value)
}

/// Check if we're at the end of the token stream
fn is_at_end(parser: Parser) -> bool {
    let token = peek(parser);
    token_kind_equals(token.kind, TokenKind::Eof)
}

/// Get the current span
fn current_span(parser: Parser) -> Span {
    peek(parser).span
}

/// Report an error
/// Returns updated_parser
fn report_error(mut parser: Parser, message: String, span: Span) -> Parser {
    let code = String::from("E0001");
    let diag = error(code, message, span);
    parser.diagnostics = add_diagnostic(parser.diagnostics, diag);
    parser
}

/// Synchronize after an error
/// Returns updated_parser
fn synchronize(mut parser: Parser) -> Parser {
    parser = advance(parser);
    
    while !is_at_end(parser.clone()) {
        let token = peek(parser.clone());
        
        // Stop at statement boundaries
        match token.kind {
            TokenKind::Fn => break,
            TokenKind::Struct => break,
            TokenKind::Enum => break,
            TokenKind::Let => break,
            TokenKind::Return => break,
            TokenKind::If => break,
            TokenKind::While => break,
            TokenKind::For => break,
            _ => {}
        }
        
        parser = advance(parser);
    }
    parser
}

// Error recovery helpers

fn error_item() -> Item {
    let empty = "";
    let span = unknown_span();
    Item::Error(ErrorItem {
        span: span
    })
}

fn error_type() -> Type {
    Type::Error
}

fn error_expression() -> Expression {
    Expression::Error(ErrorExpr {})
}

fn unit_type() -> Type {
    Type::Unit
}

// Type conversion helpers for Core-0 compliance

/// Convert usize to i32 (Core-0 doesn't support `as` casts)
fn usize_to_i32(value: usize) -> i32 {
    // In Core-0, we use a builtin conversion function
    value as i32
}

/// Convert i32 to usize (Core-0 doesn't support `as` casts)
fn i32_to_usize(value: i32) -> usize {
    // In Core-0, we use a builtin conversion function
    value as usize
}
