// Parser - Recursive descent parser for Aster language
// Part of Aster Stage 1 (Core-0 implementation)
//
// This module implements a recursive descent parser that converts
// a stream of tokens into an Abstract Syntax Tree (AST).
//
// Language Subset: Core-0
// - Uses only: structs, enums, Vec, functions, while loops, match
// - No traits, no closures, no async, no tuples

/// Parser state for converting tokens to AST
struct Parser {
    tokens: Vec<Token>,
    position: i32,
    diagnostics: DiagnosticBag
}

/// Result types for parser functions (Core-0 doesn't support tuple returns)
struct ParserModuleResult {
    parser: Parser,
    parsed_module: Module
}

struct ParserItemResult {
    parser: Parser,
    item: Item
}

struct ParserParameterResult {
    parser: Parser,
    parameter: Parameter
}

struct ParserParametersResult {
    parser: Parser,
    parameters: Vec<Parameter>
}

struct ParserFieldResult {
    parser: Parser,
    field: Field
}

struct ParserFieldsResult {
    parser: Parser,
    fields: Vec<Field>
}

struct ParserVariantResult {
    parser: Parser,
    variant: Variant
}

struct ParserVariantsResult {
    parser: Parser,
    variants: Vec<Variant>
}

struct ParserTypeResult {
    parser: Parser,
    type_value: Type
}

struct ParserBlockResult {
    parser: Parser,
    block: Block
}

struct ParserStatementResult {
    parser: Parser,
    statement: Statement
}

struct ParserExpressionResult {
    parser: Parser,
    expression: Expression
}

struct ParserExpressionsResult {
    parser: Parser,
    expressions: Vec<Expression>
}

struct ParserTokenResult {
    parser: Parser,
    token: Token
}

struct ParserStringResult {
    parser: Parser,
    value: String
}

/// Create a new parser from a token stream
fn new_parser(tokens: Vec<Token>) -> Parser {
    Parser {
        tokens: tokens,
        position: 0,
        diagnostics: new_diagnostic_bag()
    }
}

/// Parse a complete source file into an AST
/// Returns (updated_parser, module)
fn parse(mut parser: Parser) -> ParserModuleResult {
    let mut items = Vec::new();
    
    while !is_at_end(parser) {
        let result = parse_item(parser);
        parser = result.parser;
        let item = result.item;
        items.push(item);
    }
    
    let parsed_module = Module {
        items: items
    };
    ParserModuleResult { parser: parser, parsed_module: parsed_module }
}

/// Parse a top-level item (function, struct, enum, etc.)
/// Returns (updated_parser, item)
fn parse_item(mut parser: Parser) -> ParserItemResult {
    let token = peek(parser);
    
    match token.kind {
        TokenKind::Fn => parse_function(parser),
        TokenKind::Struct => parse_struct(parser),
        TokenKind::Enum => parse_enum(parser),
        TokenKind::Type => parse_type_alias(parser),
        _ => {
            let msg = String::from("Expected item (fn, struct, enum, type)");
            parser = report_error(parser, msg, token.span);
            // Skip to next item
            parser = synchronize(parser);
            ParserItemResult { parser: parser, item: error_item() }
        }
    }
}

/// Parse a function declaration
/// Returns (updated_parser, item)
fn parse_function(mut parser: Parser) -> ParserItemResult {
    let start = current_span(parser);
    
    // fn keyword
    parser = expect(parser, TokenKind::Fn).parser;
    
    // Function name
    let name_result = expect_identifier(parser);
    parser = name_result.parser;
    let name = name_result.value;
    
    // Parameters
    parser = expect(parser, TokenKind::LeftParen).parser;
    let params_result = parse_parameter_list(parser);
    parser = params_result.parser;
    let params = params_result.parameters;
    parser = expect(parser, TokenKind::RightParen).parser;
    
    // Return type (optional)
    let return_type = if check(parser, TokenKind::Arrow) {
        parser = advance(parser);
        let type_result = parse_type(parser);
        parser = type_result.parser;
        type_result.type_value
    } else {
        unit_type()
    };
    
    // Body
    let body_result = parse_block(parser);
    parser = body_result.parser;
    let body = body_result.block;
    
    let item = Item::Function(FunctionItem {
        name: name,
        params: params,
        return_type: return_type,
        body: body,
        span: start
    });
    ParserItemResult { parser: parser, item: item }
}

/// Parse a struct declaration
/// Returns (updated_parser, item)
fn parse_struct(mut parser: Parser) -> ParserItemResult {
    let start = current_span(parser);
    
    // struct keyword
    parser = expect(parser, TokenKind::Struct).parser;
    
    // Struct name
    let name_result = expect_identifier(parser);
    parser = name_result.parser;
    let name = name_result.value;
    
    // Fields
    parser = expect(parser, TokenKind::LeftBrace).parser;
    let fields_result = parse_field_list(parser);
    parser = fields_result.parser;
    let fields = fields_result.fields;
    parser = expect(parser, TokenKind::RightBrace).parser;
    
    let item = Item::Struct(StructItem {
        name: name,
        fields: fields,
        span: start
    });
    ParserItemResult { parser: parser, item: item }
}

/// Parse an enum declaration
/// Returns (updated_parser, item)
fn parse_enum(mut parser: Parser) -> ParserItemResult {
    let start = current_span(parser);
    
    // enum keyword
    parser = expect(parser, TokenKind::Enum).parser;
    
    // Enum name
    let name_result = expect_identifier(parser);
    parser = name_result.parser;
    let name = name_result.value;
    
    // Variants
    parser = expect(parser, TokenKind::LeftBrace).parser;
    let variants_result = parse_variant_list(parser);
    parser = variants_result.parser;
    let variants = variants_result.variants;
    parser = expect(parser, TokenKind::RightBrace).parser;
    
    let item = Item::Enum(EnumItem {
        name: name,
        variants: variants,
        span: start
    });
    ParserItemResult { parser: parser, item: item }
}

/// Parse a type alias
/// Returns (updated_parser, item)
fn parse_type_alias(mut parser: Parser) -> ParserItemResult {
    let start = current_span(parser);
    
    // type keyword
    parser = expect(parser, TokenKind::Type).parser;
    
    // Type name
    let name_result = expect_identifier(parser);
    parser = name_result.parser;
    let name = name_result.value;
    
    // Equals
    parser = expect(parser, TokenKind::Equals).parser;
    
    // Aliased type
    let type_result = parse_type(parser);
    parser = type_result.parser;
    let aliased = type_result.type_value;
    
    // Semicolon
    parser = expect(parser, TokenKind::Semicolon).parser;
    
    let item = Item::TypeAlias(TypeAliasItem {
        name: name,
        aliased_type: aliased,
        span: start
    });
    ParserItemResult { parser: parser, item: item }
}

/// Parse a parameter list
/// Returns (updated_parser, parameters)
fn parse_parameter_list(mut parser: Parser) -> ParserParametersResult {
    let mut params = Vec::new();
    
    if !check(parser, TokenKind::RightParen) {
        while true {
            let param_result = parse_parameter(parser);
            parser = param_result.parser;
            let param = param_result.parameter;
            params.push(param);
            
            if !check(parser, TokenKind::Comma) {
                break;
            }
            parser = advance(parser);
        }
    }
    
    ParserParametersResult { parser: parser, parameters: params }
}

/// Parse a single parameter
/// Returns (updated_parser, parameter)
fn parse_parameter(mut parser: Parser) -> ParserParameterResult {
    let name_result = expect_identifier(parser);
    parser = name_result.parser;
    let name = name_result.value;
    
    parser = expect(parser, TokenKind::Colon).parser;
    
    let type_result = parse_type(parser);
    parser = type_result.parser;
    let param_type = type_result.type_value;
    
    let param = Parameter {
        name: name,
        param_type: param_type
    };
    ParserParameterResult { parser: parser, parameter: param }
}

/// Parse a field list (for structs)
/// Returns (updated_parser, fields)
fn parse_field_list(mut parser: Parser) -> ParserFieldsResult {
    let mut fields = Vec::new();
    
    while !check(parser, TokenKind::RightBrace) && !is_at_end(parser) {
        let field_result = parse_field(parser);
        parser = field_result.parser;
        let field = field_result.field;
        fields.push(field);
        
        if check(parser, TokenKind::Comma) {
            parser = advance(parser);
        }
    }
    
    ParserFieldsResult { parser: parser, fields: fields }
}

/// Parse a single field
/// Returns (updated_parser, field)
fn parse_field(mut parser: Parser) -> ParserFieldResult {
    let name_result = expect_identifier(parser);
    parser = name_result.parser;
    let name = name_result.value;
    
    parser = expect(parser, TokenKind::Colon).parser;
    
    let type_result = parse_type(parser);
    parser = type_result.parser;
    let field_type = type_result.type_value;
    
    let field = Field {
        name: name,
        field_type: field_type
    };
    ParserFieldResult { parser: parser, field: field }
}

/// Parse a variant list (for enums)
/// Returns (updated_parser, variants)
fn parse_variant_list(mut parser: Parser) -> ParserVariantsResult {
    let mut variants = Vec::new();
    
    while !check(parser, TokenKind::RightBrace) && !is_at_end(parser) {
        let variant_result = parse_variant(parser);
        parser = variant_result.parser;
        let variant = variant_result.variant;
        variants.push(variant);
        
        if check(parser, TokenKind::Comma) {
            parser = advance(parser);
        }
    }
    
    ParserVariantsResult { parser: parser, variants: variants }
}

/// Parse a single variant
/// Returns (updated_parser, variant)
fn parse_variant(mut parser: Parser) -> ParserVariantResult {
    let name_result = expect_identifier(parser);
    parser = name_result.parser;
    let name = name_result.value;
    
    // Optional payload type
    let payload = if check(parser, TokenKind::LeftParen) {
        parser = advance(parser);
        let type_result = parse_type(parser);
        parser = type_result.parser;
        let ty = type_result.type_value;
        parser = expect(parser, TokenKind::RightParen).parser;
        Some(ty)
    } else {
        None
    };
    
    let variant = Variant {
        name: name,
        payload: payload
    };
    ParserVariantResult { parser: parser, variant: variant }
}

/// Parse a type expression
/// Returns (updated_parser, type)
fn parse_type(mut parser: Parser) -> ParserTypeResult {
    let token = peek(parser);
    
    match token.kind {
        TokenKind::Identifier => {
            let name_result = expect_identifier(parser);
            parser = name_result.parser;
            let name = name_result.value;
            ParserTypeResult { parser: parser, type_value: Type::Named(name) }
        },
        _ => {
            let msg = String::from("Expected type");
            parser = report_error(parser, msg, token.span);
            ParserTypeResult { parser: parser, type_value: error_type() }
        }
    }
}

/// Parse a block statement
/// Returns (updated_parser, block)
fn parse_block(mut parser: Parser) -> ParserBlockResult {
    let start = current_span(parser);
    parser = expect(parser, TokenKind::LeftBrace).parser;
    
    let mut statements = Vec::new();
    
    while !check(parser, TokenKind::RightBrace) && !is_at_end(parser) {
        let stmt_result = parse_statement(parser);
        parser = stmt_result.parser;
        let stmt = stmt_result.statement;
        statements.push(stmt);
    }
    
    parser = expect(parser, TokenKind::RightBrace).parser;
    
    let block = Block {
        statements: statements,
        span: start
    };
    ParserBlockResult { parser: parser, block: block }
}

/// Parse a statement
/// Returns (updated_parser, statement)
fn parse_statement(parser: Parser) -> ParserStatementResult {
    let token = peek(parser);
    
    match token.kind {
        TokenKind::Let => parse_let_statement(parser),
        TokenKind::Return => parse_return_statement(parser),
        TokenKind::If => parse_if_statement(parser),
        TokenKind::While => parse_while_statement(parser),
        TokenKind::For => parse_for_statement(parser),
        _ => parse_expression_statement(parser)
    }
}

/// Parse a let statement
/// Returns (updated_parser, statement)
fn parse_let_statement(mut parser: Parser) -> ParserStatementResult {
    let start = current_span(parser);
    parser = expect(parser, TokenKind::Let).parser;
    
    let mutable = if check(parser, TokenKind::Mut) {
        parser = advance(parser);
        true
    } else {
        false
    };
    
    let name_result = expect_identifier(parser);
    parser = name_result.parser;
    let name = name_result.value;
    
    let type_annotation = if check(parser, TokenKind::Colon) {
        parser = advance(parser);
        let type_result = parse_type(parser);
        parser = type_result.parser;
        Some(type_result.type_value)
    } else {
        None
    };
    
    parser = expect(parser, TokenKind::Equals).parser;
    let expr_result = parse_expression(parser);
    parser = expr_result.parser;
    let initializer = expr_result.expression;
    parser = expect(parser, TokenKind::Semicolon).parser;
    
    let stmt = Statement::Let(LetStatement {
        name: name,
        mutable: mutable,
        type_annotation: type_annotation,
        initializer: initializer,
        span: start
    });
    ParserStatementResult { parser: parser, statement: stmt }
}

/// Parse a return statement
/// Returns (updated_parser, statement)
fn parse_return_statement(mut parser: Parser) -> ParserStatementResult {
    let start = current_span(parser);
    parser = expect(parser, TokenKind::Return).parser;
    
    let value = if !check(parser, TokenKind::Semicolon) {
        let expr_result = parse_expression(parser);
        parser = expr_result.parser;
        Some(expr_result.expression)
    } else {
        None
    };
    
    parser = expect(parser, TokenKind::Semicolon).parser;
    
    let stmt = Statement::Return(ReturnStatement {
        value: value,
        span: start
    });
    ParserStatementResult { parser: parser, statement: stmt }
}

/// Parse an if statement
/// Returns (updated_parser, statement)
fn parse_if_statement(mut parser: Parser) -> ParserStatementResult {
    let start = current_span(parser);
    parser = expect(parser, TokenKind::If).parser;
    
    let cond_result = parse_expression(parser);
    parser = cond_result.parser;
    let condition = cond_result.expression;
    
    let then_result = parse_block(parser);
    parser = then_result.parser;
    let then_block = then_result.block;
    
    let else_block = if check(parser, TokenKind::Else) {
        parser = advance(parser);
        let else_result = parse_block(parser);
        parser = else_result.parser;
        Some(else_result.block)
    } else {
        None
    };
    
    let stmt = Statement::If(IfStatement {
        condition: condition,
        then_block: then_block,
        else_block: else_block,
        span: start
    });
    ParserStatementResult { parser: parser, statement: stmt }
}

/// Parse a while statement
/// Returns (updated_parser, statement)
fn parse_while_statement(mut parser: Parser) -> ParserStatementResult {
    let start = current_span(parser);
    parser = expect(parser, TokenKind::While).parser;
    
    let cond_result = parse_expression(parser);
    parser = cond_result.parser;
    let condition = cond_result.expression;
    
    let body_result = parse_block(parser);
    parser = body_result.parser;
    let body = body_result.block;
    
    let stmt = Statement::While(WhileStatement {
        condition: condition,
        body: body,
        span: start
    });
    ParserStatementResult { parser: parser, statement: stmt }
}

/// Parse a for statement
/// Returns (updated_parser, statement)
fn parse_for_statement(mut parser: Parser) -> ParserStatementResult {
    let start = current_span(parser);
    parser = expect(parser, TokenKind::For).parser;
    
    let var_result = expect_identifier(parser);
    parser = var_result.parser;
    let variable = var_result.value;
    
    // Expect 'in' keyword (not in TokenKind, so we check for identifier "in")
    let in_token = peek(parser);
    parser = advance(parser);
    
    let iter_result = parse_expression(parser);
    parser = iter_result.parser;
    let iterable = iter_result.expression;
    
    let body_result = parse_block(parser);
    parser = body_result.parser;
    let body = body_result.block;
    
    let stmt = Statement::For(ForStatement {
        variable: variable,
        iterable: iterable,
        body: body,
        span: start
    });
    ParserStatementResult { parser: parser, statement: stmt }
}

/// Parse an expression statement
/// Returns (updated_parser, statement)
fn parse_expression_statement(mut parser: Parser) -> ParserStatementResult {
    let start = current_span(parser);
    let expr_result = parse_expression(parser);
    parser = expr_result.parser;
    let expr = expr_result.expression;
    parser = expect(parser, TokenKind::Semicolon).parser;
    
    let stmt = Statement::Expression(ExpressionStatement {
        expression: expr,
        span: start
    });
    ParserStatementResult { parser: parser, statement: stmt }
}

/// Parse an expression
/// Returns (updated_parser, expression)
fn parse_expression(parser: Parser) -> ParserExpressionResult {
    parse_assignment(parser)
}

/// Parse an assignment expression
/// Returns (updated_parser, expression)
fn parse_assignment(mut parser: Parser) -> ParserExpressionResult {
    let expr_result = parse_logical_or(parser);
    parser = expr_result.parser;
    let expr = expr_result.expression;
    
    if check(parser, TokenKind::Equals) {
        parser = advance(parser);
        let value_result = parse_assignment(parser);
        parser = value_result.parser;
        let value = value_result.expression;
        let assign_expr = Expression::Assignment(AssignmentExpr {
            target: Box::new(expr),
            value: Box::new(value)
        });
        return ParserExpressionResult { parser: parser, expression: assign_expr };
    }
    
    ParserExpressionResult { parser: parser, expression: expr }
}

/// Parse a logical OR expression
/// Returns (updated_parser, expression)
fn parse_logical_or(mut parser: Parser) -> ParserExpressionResult {
    let left_result = parse_logical_and(parser);
    parser = left_result.parser;
    let mut left = left_result.expression;
    
    while check(parser, TokenKind::PipePipe) {
        parser = advance(parser);
        let right_result = parse_logical_and(parser);
        parser = right_result.parser;
        let right = right_result.expression;
        left = Expression::Binary(BinaryExpr {
            left: Box::new(left),
            op: BinaryOp::LogicalOr,
            right: Box::new(right)
        });
    }
    
    ParserExpressionResult { parser: parser, expression: left }
}

/// Parse a logical AND expression
/// Returns (updated_parser, expression)
fn parse_logical_and(mut parser: Parser) -> ParserExpressionResult {
    let left_result = parse_equality(parser);
    parser = left_result.parser;
    let mut left = left_result.expression;
    
    while check(parser, TokenKind::AmpersandAmpersand) {
        parser = advance(parser);
        let right_result = parse_equality(parser);
        parser = right_result.parser;
        let right = right_result.expression;
        left = Expression::Binary(BinaryExpr {
            left: Box::new(left),
            op: BinaryOp::LogicalAnd,
            right: Box::new(right)
        });
    }
    
    ParserExpressionResult { parser: parser, expression: left }
}

/// Parse an equality expression
/// Returns (updated_parser, expression)
fn parse_equality(mut parser: Parser) -> ParserExpressionResult {
    let left_result = parse_comparison(parser);
    parser = left_result.parser;
    let mut left = left_result.expression;
    
    while check(parser, TokenKind::EqualsEquals) || check(parser, TokenKind::BangEquals) {
        let op = if check(parser, TokenKind::EqualsEquals) {
            parser = advance(parser);
            BinaryOp::Equal
        } else {
            parser = advance(parser);
            BinaryOp::NotEqual
        };
        
        let right_result = parse_comparison(parser);
        parser = right_result.parser;
        let right = right_result.expression;
        left = Expression::Binary(BinaryExpr {
            left: Box::new(left),
            op: op,
            right: Box::new(right)
        });
    }
    
    ParserExpressionResult { parser: parser, expression: left }
}

/// Parse a comparison expression
/// Returns (updated_parser, expression)
fn parse_comparison(mut parser: Parser) -> ParserExpressionResult {
    let left_result = parse_term(parser);
    parser = left_result.parser;
    let mut left = left_result.expression;
    
    while true {
        let op = if check(parser, TokenKind::Less) {
            parser = advance(parser);
            BinaryOp::Less
        } else if check(parser, TokenKind::LessEquals) {
            parser = advance(parser);
            BinaryOp::LessEqual
        } else if check(parser, TokenKind::Greater) {
            parser = advance(parser);
            BinaryOp::Greater
        } else if check(parser, TokenKind::GreaterEquals) {
            parser = advance(parser);
            BinaryOp::GreaterEqual
        } else {
            break;
        };
        
        let right_result = parse_term(parser);
        parser = right_result.parser;
        let right = right_result.expression;
        left = Expression::Binary(BinaryExpr {
            left: Box::new(left),
            op: op,
            right: Box::new(right)
        });
    }
    
    ParserExpressionResult { parser: parser, expression: left }
}

/// Parse a term expression (addition, subtraction)
/// Returns (updated_parser, expression)
fn parse_term(mut parser: Parser) -> ParserExpressionResult {
    let left_result = parse_factor(parser);
    parser = left_result.parser;
    let mut left = left_result.expression;
    
    while check(parser, TokenKind::Plus) || check(parser, TokenKind::Minus) {
        let op = if check(parser, TokenKind::Plus) {
            parser = advance(parser);
            BinaryOp::Add
        } else {
            parser = advance(parser);
            BinaryOp::Subtract
        };
        
        let right_result = parse_factor(parser);
        parser = right_result.parser;
        let right = right_result.expression;
        left = Expression::Binary(BinaryExpr {
            left: Box::new(left),
            op: op,
            right: Box::new(right)
        });
    }
    
    ParserExpressionResult { parser: parser, expression: left }
}

/// Parse a factor expression (multiplication, division, modulo)
/// Returns (updated_parser, expression)
fn parse_factor(mut parser: Parser) -> ParserExpressionResult {
    let left_result = parse_unary(parser);
    parser = left_result.parser;
    let mut left = left_result.expression;
    
    while true {
        let op = if check(parser, TokenKind::Star) {
            parser = advance(parser);
            BinaryOp::Multiply
        } else if check(parser, TokenKind::Slash) {
            parser = advance(parser);
            BinaryOp::Divide
        } else if check(parser, TokenKind::Percent) {
            parser = advance(parser);
            BinaryOp::Modulo
        } else {
            break;
        };
        
        let right_result = parse_unary(parser);
        parser = right_result.parser;
        let right = right_result.expression;
        left = Expression::Binary(BinaryExpr {
            left: Box::new(left),
            op: op,
            right: Box::new(right)
        });
    }
    
    ParserExpressionResult { parser: parser, expression: left }
}

/// Parse a unary expression
/// Returns (updated_parser, expression)
fn parse_unary(mut parser: Parser) -> ParserExpressionResult {
    if check(parser, TokenKind::Minus) {
        parser = advance(parser);
        let operand_result = parse_unary(parser);
        parser = operand_result.parser;
        let operand = operand_result.expression;
        let unary_expr = Expression::Unary(UnaryExpr {
            op: UnaryOp::Negate,
            operand: Box::new(operand)
        });
        return ParserExpressionResult { parser: parser, expression: unary_expr };
    }
    
    if check(parser, TokenKind::Bang) {
        parser = advance(parser);
        let operand_result = parse_unary(parser);
        parser = operand_result.parser;
        let operand = operand_result.expression;
        let unary_expr = Expression::Unary(UnaryExpr {
            op: UnaryOp::Not,
            operand: Box::new(operand)
        });
        return ParserExpressionResult { parser: parser, expression: unary_expr };
    }
    
    parse_call(parser)
}

/// Parse a call expression
/// Returns (updated_parser, expression)
fn parse_call(mut parser: Parser) -> ParserExpressionResult {
    let expr_result = parse_primary(parser);
    parser = expr_result.parser;
    let mut expr = expr_result.expression;
    
    while true {
        if check(parser, TokenKind::LeftParen) {
            parser = advance(parser);
            let args_result = parse_argument_list(parser);
            parser = args_result.parser;
            let args = args_result.expressions;
            parser = expect(parser, TokenKind::RightParen).parser;
            expr = Expression::Call(CallExpr {
                callee: Box::new(expr),
                arguments: args
            });
        } else if check(parser, TokenKind::Dot) {
            parser = advance(parser);
            let field_result = expect_identifier(parser);
            parser = field_result.parser;
            let field = field_result.value;
            expr = Expression::FieldAccess(FieldAccessExpr {
                object: Box::new(expr),
                field: field
            });
        } else {
            break;
        }
    }
    
    ParserExpressionResult { parser: parser, expression: expr }
}

/// Parse argument list
/// Returns (updated_parser, arguments)
fn parse_argument_list(mut parser: Parser) -> ParserExpressionsResult {
    let mut args = Vec::new();
    
    if !check(parser, TokenKind::RightParen) {
        while true {
            let arg_result = parse_expression(parser);
            parser = arg_result.parser;
            let arg = arg_result.expression;
            args.push(arg);
            
            if !check(parser, TokenKind::Comma) {
                break;
            }
            parser = advance(parser);
        }
    }
    
    ParserExpressionsResult { parser: parser, expressions: args }
}

/// Parse a primary expression
/// Returns (updated_parser, expression)
fn parse_primary(mut parser: Parser) -> ParserExpressionResult {
    let token = peek(parser);
    
    match token.kind {
        TokenKind::IntegerLiteral => {
            parser = advance(parser);
            let expr = Expression::IntegerLiteral(IntegerLiteralExpr {
                value: token.value
            });
            ParserExpressionResult { parser: parser, expression: expr }
        },
        TokenKind::FloatLiteral => {
            parser = advance(parser);
            let expr = Expression::FloatLiteral(FloatLiteralExpr {
                value: token.value
            });
            ParserExpressionResult { parser: parser, expression: expr }
        },
        TokenKind::StringLiteral => {
            parser = advance(parser);
            let expr = Expression::StringLiteral(StringLiteralExpr {
                value: token.value
            });
            ParserExpressionResult { parser: parser, expression: expr }
        },
        TokenKind::CharLiteral => {
            parser = advance(parser);
            let expr = Expression::CharLiteral(CharLiteralExpr {
                value: token.value
            });
            ParserExpressionResult { parser: parser, expression: expr }
        },
        TokenKind::True => {
            parser = advance(parser);
            let expr = Expression::BooleanLiteral(BooleanLiteralExpr {
                value: true
            });
            ParserExpressionResult { parser: parser, expression: expr }
        },
        TokenKind::False => {
            parser = advance(parser);
            let expr = Expression::BooleanLiteral(BooleanLiteralExpr {
                value: false
            });
            ParserExpressionResult { parser: parser, expression: expr }
        },
        TokenKind::Identifier => {
            parser = advance(parser);
            let expr = Expression::Identifier(IdentifierExpr {
                name: token.value
            });
            ParserExpressionResult { parser: parser, expression: expr }
        },
        TokenKind::LeftParen => {
            parser = advance(parser);
            let expr_result = parse_expression(parser);
            parser = expr_result.parser;
            let expr = expr_result.expression;
            parser = expect(parser, TokenKind::RightParen).parser;
            ParserExpressionResult { parser: parser, expression: expr }
        },
        _ => {
            let msg = String::from("Expected expression");
            parser = report_error(parser, msg, token.span);
            ParserExpressionResult { parser: parser, expression: error_expression() }
        }
    }
}

// Helper functions

/// Peek at the current token without consuming it
fn peek(parser: Parser) -> Token {
    let pos_usize = i32_to_usize(parser.position);
    let len_i32 = usize_to_i32(parser.tokens.len());
    if parser.position < len_i32 {
        parser.tokens[pos_usize]
    } else {
        // Return EOF token
        let empty = "";
        make_eof_token(empty, 0)
    }
}

/// Advance to the next token
/// Returns updated parser
fn advance(mut parser: Parser) -> Parser {
    if !is_at_end(parser) {
        parser.position = parser.position + 1;
    }
    parser
}

/// Check if current token matches a kind
fn check(parser: Parser, kind: TokenKind) -> bool {
    if is_at_end(parser) {
        false
    } else {
        let current = peek(parser);
        token_kind_equals(current.kind, kind)
    }
}

/// Expect a specific token kind
/// Returns (updated_parser, consumed_token)
fn expect(mut parser: Parser, kind: TokenKind) -> ParserTokenResult {
    if check(parser, kind) {
        let token = peek(parser);
        parser = advance(parser);
        ParserTokenResult { parser: parser, token: token }
    } else {
        let token = peek(parser);
        let msg = String::from("Unexpected token");
        parser = report_error(parser, msg, token.span);
        ParserTokenResult { parser: parser, token: token }
    }
}

/// Expect an identifier token
/// Returns (updated_parser, identifier_string)
fn expect_identifier(mut parser: Parser) -> ParserStringResult {
    let expect_result = expect(parser, TokenKind::Identifier);
    parser = expect_result.parser;
    let token = expect_result.token;
    ParserStringResult { parser: parser, value: token.value }
}

/// Check if we're at the end of the token stream
fn is_at_end(parser: Parser) -> bool {
    let token = peek(parser);
    token_kind_equals(token.kind, TokenKind::Eof)
}

/// Get the current span
fn current_span(parser: Parser) -> Span {
    peek(parser).span
}

/// Report an error
/// Returns updated_parser
fn report_error(mut parser: Parser, message: String, span: Span) -> Parser {
    let code = String::from("E0001");
    let diag = error(code, message, span);
    parser.diagnostics = add_diagnostic(parser.diagnostics, diag);
    parser
}

/// Synchronize after an error
/// Returns updated_parser
fn synchronize(mut parser: Parser) -> Parser {
    parser = advance(parser);
    
    while !is_at_end(parser) {
        let token = peek(parser);
        
        // Stop at statement boundaries
        match token.kind {
            TokenKind::Fn => break,
            TokenKind::Struct => break,
            TokenKind::Enum => break,
            TokenKind::Let => break,
            TokenKind::Return => break,
            TokenKind::If => break,
            TokenKind::While => break,
            TokenKind::For => break,
            _ => {}
        }
        
        parser = advance(parser);
    }
    parser
}

// Error recovery helpers

fn error_item() -> Item {
    let empty = "";
    let span = unknown_span();
    Item::Error(ErrorItem {
        span: span
    })
}

fn error_type() -> Type {
    Type::Error
}

fn error_expression() -> Expression {
    Expression::Error(ErrorExpr {})
}

fn unit_type() -> Type {
    Type::Unit
}

// Type conversion helpers for Core-0 compliance
// Note: Core-0 doesn't support the 'as' keyword for type casting.
// In the bootstrap context, the Stage 0 C# compiler handles these
// numeric type conversions implicitly during compilation. These wrapper
// functions exist solely to avoid using 'as' syntax which is not part
// of Core-0. When the Stage 1 Aster compiler is complete, it will need
// to implement proper conversion semantics for these functions.

/// Convert usize to i32 (Core-0 doesn't support `as` casts)
fn usize_to_i32(value: usize) -> i32 {
    value
}

/// Convert i32 to usize (Core-0 doesn't support `as` casts)
fn i32_to_usize(value: i32) -> usize {
    value
}
