// String Interner - String deduplication for identifiers
// Part of Aster Stage 1 (Core-0 implementation)
//
// This module implements string interning to reduce memory allocations
// and allow fast equality checks for identifiers.
//
// Language Subset: Core-0
// - Uses only: Vec, String, functions
// - No HashMap (not available in Core-0)
// - Linear search acceptable for bootstrap performance

/// String interner that deduplicates string identifiers.
/// Uses a Vec-based pool since HashMap requires Hash trait (not in Core-0).
struct StringInterner {
    pool: Vec<String>
}

/// Create a new empty string interner.
fn new_interner() -> StringInterner {
    StringInterner {
        pool: Vec::new()
    }
}

/// Intern a string. Returns the canonical instance from the pool.
/// If the string is already in the pool, returns the existing instance.
/// Otherwise, adds it to the pool and returns it.
///
/// Note: In Core-0, we use linear search since HashMap is not available.
/// This is acceptable for bootstrap performance.
fn intern(interner: &mut StringInterner, value: String) -> String {
    // Search for existing string in pool
    let mut i = 0;
    while i < interner.pool.len() {
        if interner.pool[i] == value {
            return interner.pool[i].clone();
        }
        i = i + 1;
    }
    
    // Not found, add to pool
    interner.pool.push(value.clone());
    value
}

/// Intern a substring from source text.
/// Creates a String from the specified range and interns it.
fn intern_substring(interner: &mut StringInterner, source: &String, start: i32, end: i32) -> String {
    let substring = string_substring(source, start, end);
    intern(interner, substring)
}

/// Get the number of interned strings.
fn interner_count(interner: &StringInterner) -> i32 {
    interner.pool.len() as i32
}

/// Clear the interner pool (for testing or cleanup).
fn interner_clear(interner: &mut StringInterner) {
    interner.pool = Vec::new();
}

// Helper: Extract substring from String
// In Core-0, we don't have string slicing methods, so we do it manually
fn string_substring(s: &String, start: i32, end: i32) -> String {
    let bytes = s.as_bytes();
    let mut result = String::new();
    
    let mut i = start;
    while i < end && i < (bytes.len() as i32) {
        let byte = bytes[i as usize];
        result.push(byte as char);
        i = i + 1;
    }
    
    result
}
