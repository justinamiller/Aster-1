// Aster Compiler Utility Functions
// String utilities, printing, and helper functions
// Session 8: Integration utilities

// ============================================================================
// String Operations
// ============================================================================

fn int_to_string(n: i32) -> String {
    int_to_string_impl(n)
}

fn int_to_string_impl(n: i32) -> String {
    // Actual integer to string conversion using recursion
    if n == 0 {
        return "0";
    }
    if n < 0 {
        return "-" + int_to_string_impl(-n);
    }
    let digit = n % 10;
    let rest = n / 10;
    let digit_str = if digit == 0 { "0" }
        else if digit == 1 { "1" }
        else if digit == 2 { "2" }
        else if digit == 3 { "3" }
        else if digit == 4 { "4" }
        else if digit == 5 { "5" }
        else if digit == 6 { "6" }
        else if digit == 7 { "7" }
        else if digit == 8 { "8" }
        else { "9" };
    if rest == 0 {
        digit_str
    } else {
        int_to_string_impl(rest) + digit_str
    }
}

fn string_concat(a: String, b: String) -> String {
    // TODO: Actual string concatenation
    // Stub - would use Core-0 string operations
    a + b
}

fn string_length(s: String) -> i32 {
    // TODO: Actual string length
    // Stub - would call Core-0 string.len()
    0
}

fn string_equals(a: String, b: String) -> bool {
    // TODO: Actual string comparison
    // Stub - would use Core-0 string equality
    a == b
}

fn string_contains(haystack: String, needle: String) -> bool {
    // TODO: Actual substring search
    // Stub - would use Core-0 string contains method
    false
}

fn string_starts_with(s: String, prefix: String) -> bool {
    // TODO: Actual prefix check
    // Stub - would use Core-0 string starts_with method
    false
}

fn string_ends_with(s: String, suffix: String) -> bool {
    // TODO: Actual suffix check
    // Stub - would use Core-0 string ends_with method
    false
}

fn string_trim(s: String) -> String {
    // TODO: Actual whitespace trimming
    // Stub - would use Core-0 string trim method
    s
}

// ============================================================================
// Print Utilities
// ============================================================================

fn print_message(msg: String) {
    // Connected to runtime: calls extern_print_line for console output
    extern_print_line(msg)
}

fn print_error(msg: String) {
    // Print error prefixed with [ERROR] tag
    extern_print_line("[ERROR] " + msg)
}

// Stub for extern C print function - provided by runtime when linked
// In LLVM IR output, this maps to puts() or equivalent
fn extern_print_line(msg: String) {
    // Runtime-provided: outputs msg + newline to stdout
    // This will be replaced by actual implementation during linking
}

fn print_status(msg: String) {
    // TODO: Print status message (might be colored/formatted)
    // Stub - would use Core-0 printing
    print_message(msg);
}

fn print_line() {
    // Print empty line
    print_message("");
}

// ============================================================================
// String Building
// ============================================================================

fn build_error_message(phase: String, details: String) -> String {
    string_concat(string_concat("Error in ", phase), string_concat(": ", details))
}

fn build_success_message(output_file: String) -> String {
    string_concat("Successfully compiled to: ", output_file)
}

// ============================================================================
// Array/Vector Helpers (for Core-0 compatibility)
// ============================================================================

fn vec_len<T>(v: Vec<T>) -> i32 {
    // TODO: Actual vector length
    // Stub - would use Core-0 vec.len()
    0
}

fn vec_is_empty<T>(v: Vec<T>) -> bool {
    vec_len(v) == 0
}

// ============================================================================
// Option Helpers (for Core-0 compatibility)
// ============================================================================

fn option_is_some<T>(opt: Option<T>) -> bool {
    // TODO: Check if option has value
    // Stub - would use Core-0 option.is_some()
    false
}

fn option_is_none<T>(opt: Option<T>) -> bool {
    // TODO: Check if option is none
    // Stub - would use Core-0 option.is_none()
    true
}
