// Control Flow Graph (CFG) for Stage 3
// Represents program control flow for borrow checking and optimization

// Core-0 compatible: Helper struct for switch cases (instead of tuple)
struct SwitchCase {
    value: i32,
    target: i32,
}

struct BasicBlock {
    id: i32,
    statements: Vec<Statement>,
    terminator: Terminator,
    predecessors: Vec<i32>,
    successors: Vec<i32>,
}

enum Terminator {
    Return(Operand),
    Goto(i32),
    If(Operand, i32, i32),
    Switch(Operand, Vec<SwitchCase>, i32),
    Unreachable,
}

enum Statement {
    Assign(Place, Rvalue),
    StorageLive(Local),
    StorageDead(Local),
    Nop,
}

struct CFG {
    blocks: Vec<BasicBlock>,
    entry: i32,
    exit: i32,
}

// Core-0 compatible: Standalone functions instead of impl block
fn cfg_new() -> CFG {
    CFG {
        blocks: Vec::new(),
        entry: 0,
        exit: -1,
    }
}

fn cfg_add_block(cfg: &mut CFG) -> i32 {
    let id = cfg.blocks.len();
    cfg.blocks.push(BasicBlock {
        id: id,
        statements: Vec::new(),
        terminator: Terminator::Unreachable,
        predecessors: Vec::new(),
        successors: Vec::new(),
    });
    id
}

fn cfg_add_edge(cfg: &mut CFG, from: i32, to: i32) {
    // Add edge in CFG
    // Note: Direct i32 indexing (Core-0 compatible)
    cfg.blocks[from].successors.push(to);
    cfg.blocks[to].predecessors.push(from);
}

fn cfg_get_block(cfg: &CFG, id: i32) -> &BasicBlock {
    &cfg.blocks[id]
}

fn cfg_get_block_mut(cfg: &mut CFG, id: i32) -> &mut BasicBlock {
    &mut cfg.blocks[id]
}

fn build_cfg(ast: &AST) -> Result<CFG, String> {
    let mut cfg = cfg_new();
    
    // Create entry block
    cfg.entry = cfg_add_block(&mut cfg);
    
    // Build CFG from AST
    for item in &ast.items {
        match item {
            Item::Function(func) => {
                build_function_cfg(&mut cfg, func)?;
            }
            _ => {}
        }
    }
    
    Ok(cfg)
}

fn build_function_cfg(cfg: &mut CFG, func: &Function) -> Result<i32, String> {
    let entry = cfg.entry;
    let mut current_block = entry;
    
    // Process function body
    for stmt in &func.body.statements {
        current_block = build_statement_cfg(cfg, stmt, current_block)?;
    }
    
    // Add exit
    cfg.exit = cfg_add_block(cfg);
    cfg_add_edge(cfg, current_block, cfg.exit);
    
    Ok(0)
}

fn build_statement_cfg(cfg: &mut CFG, stmt: &Stmt, current: i32) -> Result<i32, String> {
    match stmt {
        Stmt::Let => {
            cfg_get_block_mut(cfg, current).statements.push(Statement::Assign(Place::Local(0), Rvalue::Use(Operand::Constant(0))));
            Ok(current)
        }
        Stmt::If => {
            let then_block = cfg_add_block(cfg);
            let else_block = cfg_add_block(cfg);
            let merge_block = cfg_add_block(cfg);
            
            cfg_get_block_mut(cfg, current).terminator = Terminator::If(Operand::Constant(0), then_block, else_block);
            cfg_add_edge(cfg, current, then_block);
            cfg_add_edge(cfg, current, else_block);
            
            cfg_add_edge(cfg, then_block, merge_block);
            cfg_add_edge(cfg, else_block, merge_block);
            
            Ok(merge_block)
        }
        _ => Ok(current)
    }
}
