// Stage 3 - Full Aster Compiler (Core-2)
// Complete self-compiling compiler with NLL, MIR, optimizations, and LLVM backend

use stage2::*;  // Import all Stage 2 components

// Compilation phases for Stage 3
enum CompilationPhase {
    Parse,
    NameResolution,
    TypeInference,
    TraitResolution,
    EffectChecking,
    OwnershipAnalysis,
    BorrowChecking,      // Stage 3: NLL borrow checker
    MIRConstruction,     // Stage 3: Build MIR
    Optimization,        // Stage 3: Optimize MIR
    LLVMCodegen,        // Stage 3: Generate LLVM IR
    Linking,            // Stage 3: Link executable
}

struct CompilerContext {
    source_files: Vec<String>,
    output_file: String,
    optimization_level: i32,
    emit_mir: bool,
    emit_llvm: bool,
    emit_asm: bool,
    phase: CompilationPhase,
    diagnostics: Vec<Diagnostic>,
    command: Command,
}

enum Command {
    Build,
    Check,
    EmitMIR,
    EmitLLVM,
    EmitAsm,
    Format,
    Lint,
    Doc,
    Test,
    LSP,
    SelfCompile,
}

fn main(args: Vec<String>) -> Result<(), String> {
    let mut ctx = CompilerContext::new();
    
    // Parse command line arguments
    parse_args(&mut ctx, &args)?;
    
    match ctx.command {
        Command::Build => compile_program(&mut ctx),
        Command::Check => check_program(&mut ctx),
        Command::EmitMIR => emit_mir_only(&mut ctx),
        Command::EmitLLVM => emit_llvm_only(&mut ctx),
        Command::EmitAsm => emit_asm_only(&mut ctx),
        Command::Format => format_files(&mut ctx),
        Command::Lint => lint_files(&mut ctx),
        Command::Doc => generate_documentation(&mut ctx),
        Command::Test => run_tests(&mut ctx),
        Command::LSP => start_lsp_server(),
        Command::SelfCompile => self_compile(&mut ctx),
    }
}

fn compile_program(ctx: &mut CompilerContext) -> Result<(), String> {
    // Phase 1: Parse all source files
    ctx.phase = CompilationPhase::Parse;
    let mut asts = Vec::new();
    for file in &ctx.source_files {
        let source = read_file(file)?;
        let ast = parse(&source)?;
        asts.push(ast);
    }
    
    // Merge ASTs
    let ast = merge_asts(asts)?;
    
    // Phase 2-6: Run all Stage 2 phases
    ctx.phase = CompilationPhase::NameResolution;
    let symbols = resolve_names(&ast)?;
    
    ctx.phase = CompilationPhase::TypeInference;
    let types = infer_types(&ast, &symbols)?;
    
    ctx.phase = CompilationPhase::TraitResolution;
    let trait_info = resolve_traits(&ast, &types)?;
    
    ctx.phase = CompilationPhase::EffectChecking;
    let effects = check_effects(&ast, &types)?;
    
    ctx.phase = CompilationPhase::OwnershipAnalysis;
    let ownership = analyze_ownership(&ast, &types)?;
    
    // Phase 7: NLL Borrow Checking (Stage 3)
    ctx.phase = CompilationPhase::BorrowChecking;
    let cfg = build_cfg(&ast)?;
    let liveness = compute_liveness(&cfg);
    let borrow_result = check_borrows(&cfg, &liveness);
    
    if !borrow_result.errors.is_empty() {
        for error in &borrow_result.errors {
            ctx.diagnostics.push(Diagnostic::from_borrow_error(error));
        }
        return Err("Borrow checking failed");
    }
    
    // Phase 8: MIR Construction (Stage 3)
    ctx.phase = CompilationPhase::MIRConstruction;
    let mut mir = build_mir(&ast)?;
    
    if ctx.emit_mir {
        write_file(&format!("{}.mir", ctx.output_file), &format_mir(&mir))?;
    }
    
    // Phase 9: Optimization (Stage 3)
    ctx.phase = CompilationPhase::Optimization;
    optimize_mir(&mut mir)?;
    
    // Phase 10: LLVM Code Generation (Stage 3)
    ctx.phase = CompilationPhase::LLVMCodegen;
    let llvm_ctx = generate_llvm(&mir)?;
    let llvm_ir = emit_llvm_ir(&llvm_ctx);
    
    if ctx.emit_llvm {
        write_file(&format!("{}.ll", ctx.output_file), &llvm_ir)?;
    }
    
    // Phase 11: Compile LLVM IR to object file
    let obj_file = compile_llvm_to_obj(&llvm_ir, &ctx)?;
    
    if ctx.emit_asm {
        let asm = llvm_to_asm(&llvm_ir)?;
        write_file(&format!("{}.s", ctx.output_file), &asm)?;
    }
    
    // Phase 12: Link executable
    ctx.phase = CompilationPhase::Linking;
    link_executable(&obj_file, &ctx.output_file)?;
    
    println!("âœ“ Compilation successful: {}", ctx.output_file);
    Ok(())
}

// Self-compilation: Compile Stage 3 with itself
fn self_compile(ctx: &mut CompilerContext) -> Result<(), String> {
    println!("=== Stage 3 Self-Compilation ===");
    
    // Step 1: Collect all Stage 3 source files
    let stage3_sources = glob("aster/compiler/stage3/*.ast")?;
    ctx.source_files = stage3_sources;
    ctx.output_file = "aster3_prime".to_string();
    
    println!("Compiling {} Stage 3 source files...", ctx.source_files.len());
    
    // Step 2: Compile with current aster3
    compile_program(ctx)?;
    
    println!("âœ“ Self-compilation successful!");
    println!("  Original: aster3");
    println!("  Generated: aster3'");
    
    // Step 3: Compare binaries
    let equivalent = compare_binaries("aster3", "aster3'")?;
    
    if equivalent {
        println!("âœ“ aster3 == aster3' (bit-identical)");
        println!("ðŸŽ‰ TRUE SELF-HOSTING ACHIEVED!");
    } else {
        println!("âš  Binaries differ (may be functionally equivalent)");
        
        // Try functional equivalence test
        let functionally_equal = test_functional_equivalence("aster3", "aster3'")?;
        if functionally_equal {
            println!("âœ“ Functional equivalence verified");
            println!("ðŸŽ‰ SELF-HOSTING ACHIEVED (functionally)!");
        }
    }
    
    Ok(())
}

impl CompilerContext {
    fn new() -> CompilerContext {
        CompilerContext {
            source_files: Vec::new(),
            output_file: String::new(),
            optimization_level: 2,
            emit_mir: false,
            emit_llvm: false,
            emit_asm: false,
            phase: CompilationPhase::Parse,
            diagnostics: Vec::new(),
            command: Command::Build,
        }
    }
}
