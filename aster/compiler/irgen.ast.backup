// IR Generation - Implementation for Stage 1
// Part of Aster Stage 1 (Core-0 implementation)
//
// Generates HIR (High-level Intermediate Representation) from AST
// HIR is close to AST but with explicit control flow and types
//
// Language Subset: Core-0
// - Uses only: structs, enums, Vec, String, functions
// - No traits, no HashMap, no methods
// - All functions are standalone

// ============================================================================
// EMBEDDED DEPENDENCIES (for self-contained compilation)
// ============================================================================

/// Generic vector type (provided by runtime)
struct Vec<T> {}

/// Boxed pointer type (provided by runtime)
struct Box<T> {}

/// Source location span within a file
struct Span {
    file: String,
    line: i32,
    column: i32,
    start: i32,
    length: i32
}

// ============================================================================
// HIR DATA STRUCTURES
// ============================================================================

/// HIR Module - top level
struct HirModule {
    functions: Vec<HirFunction>,
    function_count: i32,
    structs: Vec<HirStruct>,
    struct_count: i32
}

/// HIR Function
struct HirFunction {
    name: String,
    params: Vec<HirParam>,
    param_count: i32,
    return_type_id: i32,
    body: HirBlock,
    local_vars: Vec<HirLocal>,
    local_count: i32,
    span: Span
}

/// HIR Parameter
struct HirParam {
    name: String,
    type_id: i32,
    param_index: i32
}

/// HIR Local Variable
struct HirLocal {
    name: String,
    type_id: i32,
    is_mutable: bool,
    local_index: i32
}

/// HIR Struct
struct HirStruct {
    name: String,
    field_count: i32,
    type_id: i32
}

/// HIR Block (sequence of statements with optional result expression)
struct HirBlock {
    statements: Vec<HirStatement>,
    stmt_count: i32,
    result_expr: HirExpression,
    has_result: bool,
    type_id: i32
}

/// HIR Statement
enum HirStatement {
    Let(HirLetStmt),
    Assign(HirAssignStmt),
    ExprStmt(HirExprStmt),
    Return(HirReturnStmt),
    Empty
}

/// Let statement (variable declaration)
struct HirLetStmt {
    local: HirLocal,
    init: HirExpression,
    has_init: bool
}

/// Assignment statement
struct HirAssignStmt {
    place: HirPlace,
    value: HirExpression
}

/// Expression statement
struct HirExprStmt {
    expr: HirExpression
}

/// Return statement
struct HirReturnStmt {
    value: HirExpression,
    has_value: bool
}

/// HIR Place (location that can be assigned to)
struct HirPlace {
    kind: HirPlaceKind,
    type_id: i32
}

/// HIR Place Kind
enum HirPlaceKind {
    Local(i32),
    Field(HirFieldPlace),
    Index(HirIndexPlace)
}

/// Field access place
struct HirFieldPlace {
    base: i32,
    field_name: String
}

/// Array index place
struct HirIndexPlace {
    base: i32,
    index: i32
}

/// HIR Expression
enum HirExpression {
    Literal(HirLiteral),
    Variable(HirVariable),
    BinaryOp(HirBinaryOp),
    UnaryOp(HirUnaryOp),
    Call(HirCall),
    If(HirIf),
    Block(HirBlockExpr),
    While(HirWhile),
    For(HirFor),
    Match(HirMatch),
    FieldAccess(HirFieldAccess),
    IndexAccess(HirIndexAccess),
    StructLit(HirStructLit),
    ArrayLit(HirArrayLit),
    Invalid
}

/// HIR Literal
struct HirLiteral {
    kind: HirLiteralKind,
    type_id: i32
}

/// HIR Literal Kind
enum HirLiteralKind {
    Int(i32),
    Float(String),
    Bool(bool),
    String(String),
    Char(char)
}

/// HIR Variable reference
struct HirVariable {
    name: String,
    local_index: i32,
    type_id: i32
}

/// HIR Binary operation
struct HirBinaryOp {
    op: String,
    left: Box<HirExpression>,
    right: Box<HirExpression>,
    type_id: i32
}

/// HIR Unary operation
struct HirUnaryOp {
    op: String,
    operand: Box<HirExpression>,
    type_id: i32
}

/// HIR Function call
struct HirCall {
    func_name: String,
    args: Vec<HirExpression>,
    arg_count: i32,
    type_id: i32
}

/// HIR If expression
struct HirIf {
    condition: Box<HirExpression>,
    then_block: HirBlock,
    else_block: HirBlock,
    has_else: bool,
    type_id: i32
}

/// HIR Block expression
struct HirBlockExpr {
    block: HirBlock
}

/// HIR While loop
struct HirWhile {
    condition: Box<HirExpression>,
    body: HirBlock,
    type_id: i32
}

/// HIR For loop
struct HirFor {
    pattern: String,
    iterator: Box<HirExpression>,
    body: HirBlock,
    type_id: i32
}

/// HIR Match expression
struct HirMatch {
    scrutinee: Box<HirExpression>,
    arms: Vec<HirMatchArm>,
    arm_count: i32,
    type_id: i32
}

/// HIR Match arm
struct HirMatchArm {
    pattern: String,
    body: HirExpression
}

/// HIR Field access
struct HirFieldAccess {
    base: Box<HirExpression>,
    field_name: String,
    type_id: i32
}

/// HIR Index access
struct HirIndexAccess {
    base: Box<HirExpression>,
    index: Box<HirExpression>,
    type_id: i32
}

/// HIR Struct literal
struct HirStructLit {
    struct_name: String,
    field_count: i32,
    type_id: i32
}

/// HIR Array literal
struct HirArrayLit {
    elements: Vec<HirExpression>,
    element_count: i32,
    type_id: i32
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/// Create a dummy span
fn dummy_span_hir() -> Span {
    let empty = "";
    Span {
        file: empty,
        line: 0,
        column: 0,
        start: 0,
        length: 0
    }
}

/// Create an invalid HIR expression
fn invalid_hir_expr() -> HirExpression {
    HirExpression::Invalid
}

/// Create an empty HIR block
fn empty_hir_block() -> HirBlock {
    HirBlock {
        statements: Vec::new(),
        stmt_count: 0,
        result_expr: invalid_hir_expr(),
        has_result: false,
        type_id: 9  // void type
    }
}

// ============================================================================
// IR GENERATOR STATE
// ============================================================================

/// IR generator state
struct IrGenerator {
    module: HirModule,
    next_local: i32,
    errors: Vec<String>,
    error_count: i32
}

/// Result of IR generation
struct IrGenResult {
    generator: IrGenerator,
    success: bool
}

/// Create a new IR generator
fn new_ir_generator() -> IrGenerator {
    let empty_module = HirModule {
        functions: Vec::new(),
        function_count: 0,
        structs: Vec::new(),
        struct_count: 0
    };
    
    IrGenerator {
        module: empty_module,
        next_local: 0,
        errors: Vec::new(),
        error_count: 0
    }
}

/// Generate IR for a module (minimal)
fn generate_ir(mut gen: IrGenerator) -> IrGenResult {
    // Minimal implementation: create simple IR
    IrGenResult {
        generator: gen,
        success: true
    }
}

/// Add a function to IR module
fn add_ir_function(mut gen: IrGenerator, name: String) -> IrGenerator {
    gen.next_register = gen.next_register + 1;
    gen
}

// ============================================================================
// AST → HIR LOWERING
// ============================================================================

/// Lower a module from AST to HIR
fn lower_module(mut gen: IrGenerator) -> IrGenResult {
    // In full implementation, would:
    // 1. Iterate through all declarations in AST module
    // 2. Lower each function declaration to HIR
    // 3. Lower each struct/enum declaration
    // 4. Collect all into HirModule
    
    // For now, return success
    IrGenResult {
        generator: gen,
        success: true
    }
}

/// Lower a function declaration
fn lower_function(mut gen: IrGenerator, name: String, return_type: i32) -> IrGenerator {
    // In full implementation, would:
    // 1. Lower parameters to HirParam
    // 2. Lower body expression to HirBlock
    // 3. Collect local variables
    // 4. Create HirFunction
    // 5. Add to module
    
    // Placeholder: create empty function
    let empty_func = HirFunction {
        name: name,
        params: Vec::new(),
        param_count: 0,
        return_type_id: return_type,
        body: empty_hir_block(),
        local_vars: Vec::new(),
        local_count: 0,
        span: dummy_span_hir()
    };
    
    gen.module.function_count = gen.module.function_count + 1;
    gen
}

/// Lower an expression to HIR
fn lower_expression(gen: IrGenerator, expr_type: i32) -> (IrGenerator, HirExpression) {
    // In full implementation, would match on AST expression type:
    // - Literal → HirLiteral
    // - Variable → HirVariable
    // - BinaryOp → HirBinaryOp
    // - Call → HirCall
    // - If → HirIf
    // - Block → HirBlock
    // - While → HirWhile
    // - For → HirFor
    // - Match → HirMatch
    // - Field access → HirFieldAccess
    // - Index access → HirIndexAccess
    // - Struct literal → HirStructLit
    // - Array literal → HirArrayLit
    
    // Placeholder: return invalid expression
    (gen, invalid_hir_expr())
}

/// Lower a literal expression
fn lower_literal(gen: IrGenerator, value: i32, type_id: i32) -> (IrGenerator, HirExpression) {
    let lit = HirLiteral {
        kind: HirLiteralKind::Int(value),
        type_id: type_id
    };
    
    (gen, HirExpression::Literal(lit))
}

/// Lower a variable reference
fn lower_variable(gen: IrGenerator, name: String, type_id: i32) -> (IrGenerator, HirExpression) {
    let var = HirVariable {
        name: name,
        local_index: -1,  // Would be resolved during lowering
        type_id: type_id
    };
    
    (gen, HirExpression::Variable(var))
}

/// Lower a binary operation
fn lower_binary_op(mut gen: IrGenerator, op: String, left_type: i32, right_type: i32, result_type: i32) -> (IrGenerator, HirExpression) {
    // In full implementation, would recursively lower left and right
    // For now, create structure with invalid operands
    
    let bin_op = HirBinaryOp {
        op: op,
        left: Box::new(invalid_hir_expr()),
        right: Box::new(invalid_hir_expr()),
        type_id: result_type
    };
    
    (gen, HirExpression::BinaryOp(bin_op))
}

/// Lower a function call
fn lower_call(gen: IrGenerator, func_name: String, arg_count: i32, return_type: i32) -> (IrGenerator, HirExpression) {
    let call = HirCall {
        func_name: func_name,
        args: Vec::new(),
        arg_count: arg_count,
        type_id: return_type
    };
    
    (gen, HirExpression::Call(call))
}

/// Lower an if expression
fn lower_if(gen: IrGenerator, has_else: bool, type_id: i32) -> (IrGenerator, HirExpression) {
    let if_expr = HirIf {
        condition: Box::new(invalid_hir_expr()),
        then_block: empty_hir_block(),
        else_block: empty_hir_block(),
        has_else: has_else,
        type_id: type_id
    };
    
    (gen, HirExpression::If(if_expr))
}

/// Lower a while loop
fn lower_while(gen: IrGenerator, type_id: i32) -> (IrGenerator, HirExpression) {
    let while_expr = HirWhile {
        condition: Box::new(invalid_hir_expr()),
        body: empty_hir_block(),
        type_id: type_id
    };
    
    (gen, HirExpression::While(while_expr))
}

/// Lower a for loop
fn lower_for(gen: IrGenerator, pattern: String, type_id: i32) -> (IrGenerator, HirExpression) {
    let for_expr = HirFor {
        pattern: pattern,
        iterator: Box::new(invalid_hir_expr()),
        body: empty_hir_block(),
        type_id: type_id
    };
    
    (gen, HirExpression::For(for_expr))
}

/// Lower a block expression
fn lower_block(gen: IrGenerator, type_id: i32) -> (IrGenerator, HirExpression) {
    let block_expr = HirBlockExpr {
        block: empty_hir_block()
    };
    
    (gen, HirExpression::Block(block_expr))
}

/// Lower a match expression
fn lower_match(gen: IrGenerator, type_id: i32) -> (IrGenerator, HirExpression) {
    let match_expr = HirMatch {
        scrutinee: Box::new(invalid_hir_expr()),
        arms: Vec::new(),
        arm_count: 0,
        type_id: type_id
    };
    
    (gen, HirExpression::Match(match_expr))
}

/// Lower a field access
fn lower_field_access(gen: IrGenerator, field_name: String, type_id: i32) -> (IrGenerator, HirExpression) {
    let field_access = HirFieldAccess {
        base: Box::new(invalid_hir_expr()),
        field_name: field_name,
        type_id: type_id
    };
    
    (gen, HirExpression::FieldAccess(field_access))
}

/// Lower an index access
fn lower_index_access(gen: IrGenerator, type_id: i32) -> (IrGenerator, HirExpression) {
    let index_access = HirIndexAccess {
        base: Box::new(invalid_hir_expr()),
        index: Box::new(invalid_hir_expr()),
        type_id: type_id
    };
    
    (gen, HirExpression::IndexAccess(index_access))
}

/// Lower a struct literal
fn lower_struct_lit(gen: IrGenerator, struct_name: String, field_count: i32, type_id: i32) -> (IrGenerator, HirExpression) {
    let struct_lit = HirStructLit {
        struct_name: struct_name,
        field_count: field_count,
        type_id: type_id
    };
    
    (gen, HirExpression::StructLit(struct_lit))
}

/// Lower an array literal
fn lower_array_lit(gen: IrGenerator, element_count: i32, type_id: i32) -> (IrGenerator, HirExpression) {
    let array_lit = HirArrayLit {
        elements: Vec::new(),
        element_count: element_count,
        type_id: type_id
    };
    
    (gen, HirExpression::ArrayLit(array_lit))
}

// ============================================================================
// STATEMENT LOWERING
// ============================================================================

/// Lower a statement
fn lower_statement(gen: IrGenerator) -> (IrGenerator, HirStatement) {
    // In full implementation, would match on AST statement type
    // For now, return empty statement
    (gen, HirStatement::Empty)
}

/// Lower a let statement
fn lower_let_stmt(gen: IrGenerator, name: String, type_id: i32, is_mutable: bool) -> (IrGenerator, HirStatement) {
    let local = HirLocal {
        name: name,
        type_id: type_id,
        is_mutable: is_mutable,
        local_index: gen.next_local
    };
    
    let let_stmt = HirLetStmt {
        local: local,
        init: invalid_hir_expr(),
        has_init: false
    };
    
    (gen, HirStatement::Let(let_stmt))
}

/// Lower an assignment statement
fn lower_assign_stmt(gen: IrGenerator, local_index: i32, type_id: i32) -> (IrGenerator, HirStatement) {
    let place = HirPlace {
        kind: HirPlaceKind::Local(local_index),
        type_id: type_id
    };
    
    let assign_stmt = HirAssignStmt {
        place: place,
        value: invalid_hir_expr()
    };
    
    (gen, HirStatement::Assign(assign_stmt))
}

/// Lower an expression statement
fn lower_expr_stmt(gen: IrGenerator) -> (IrGenerator, HirStatement) {
    let expr_stmt = HirExprStmt {
        expr: invalid_hir_expr()
    };
    
    (gen, HirStatement::ExprStmt(expr_stmt))
}

/// Lower a return statement
fn lower_return_stmt(gen: IrGenerator, has_value: bool) -> (IrGenerator, HirStatement) {
    let return_stmt = HirReturnStmt {
        value: invalid_hir_expr(),
        has_value: has_value
    };
    
    (gen, HirStatement::Return(return_stmt))
}

// ============================================================================
// LOCAL VARIABLE COLLECTION
// ============================================================================

/// Collect local variables from HIR block
fn collect_locals_from_block(block: HirBlock) -> Vec<HirLocal> {
    // In full implementation, would:
    // 1. Traverse all statements in block
    // 2. Find all Let statements
    // 3. Extract HirLocal from each
    // 4. Return list of all locals
    
    // For now, return empty list
    Vec::new()
}

/// Collect all locals from HIR function body
fn collect_locals(func: HirFunction) -> Vec<HirLocal> {
    collect_locals_from_block(func.body)
}

/// Count local variables in function
fn count_locals(func: HirFunction) -> i32 {
    func.local_count
}

// ============================================================================
// HIR VALIDATION
// ============================================================================

/// Validate HIR module structure
fn validate_hir_module(module: HirModule) -> bool {
    // In full implementation, would check:
    // 1. All function names unique
    // 2. All type IDs valid
    // 3. All variable references valid
    // 4. Control flow well-formed
    
    // For now, always valid
    true
}

/// Validate HIR function
fn validate_hir_function(func: HirFunction) -> bool {
    // In full implementation, would check:
    // 1. All local indices valid
    // 2. All type IDs consistent
    // 3. Return type matches body type
    
    // For now, always valid
    true
}

/// Validate HIR expression
fn validate_hir_expression(expr: HirExpression) -> bool {
    // In full implementation, would recursively validate
    // all sub-expressions and type consistency
    
    // For now, always valid
    true
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/// Get function count
fn get_function_count(gen: IrGenerator) -> i32 {
    gen.module.function_count
}

/// Get error count
fn get_ir_error_count(gen: IrGenerator) -> i32 {
    gen.error_count
}

/// Check if IR generation has errors
fn has_ir_errors(gen: IrGenerator) -> bool {
    gen.error_count > 0
}

/// Get next local index
fn get_next_local_index(gen: IrGenerator) -> i32 {
    gen.next_local
}

/// Allocate a new local index
fn allocate_local(mut gen: IrGenerator) -> IrGenerator {
    gen.next_local = gen.next_local + 1;
    gen
}

/// Add an error message
fn add_ir_error(mut gen: IrGenerator, message: String) -> IrGenerator {
    gen.error_count = gen.error_count + 1;
    gen
}
