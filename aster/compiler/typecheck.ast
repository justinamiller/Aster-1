// Type Checking - Implementation for Stage 1
// Part of Aster Stage 1 (Core-0 implementation)
//
// This module implements type checking and type inference for Aster programs.
// It uses a simplified Hindley-Milner style type inference with constraints.
//
// Language Subset: Core-0
// - Uses only: structs, enums, Vec, String, functions
// - No traits, no HashMap, no methods
// - All functions are standalone

// ============================================================================
// EMBEDDED DEPENDENCIES (for self-contained compilation)
// ============================================================================

/// Generic vector type (provided by runtime)
struct Vec<T> {}

/// Boxed pointer type (provided by runtime)
struct Box<T> {}

/// Source location span within a file
struct Span {
    file: String,
    line: i32,
    column: i32,
    start: i32,
    length: i32
}

// ============================================================================
// TYPE REPRESENTATION
// ============================================================================

/// Primitive type kinds
enum PrimitiveType {
    I32,
    I64,
    U32,
    U64,
    F32,
    F64,
    Bool,
    Char,
    String,
    Void
}

/// Complete type representation
enum Type {
    Primitive(PrimitiveType),
    Struct(StructType),
    Enum(EnumType),
    Function(FunctionType),
    Array(ArrayType),
    Pointer(PointerType),
    Reference(ReferenceType),
    TypeVariable(TypeVar),
    Unknown,
    Error
}

/// Struct type information
struct StructType {
    name: String,
    field_count: i32
}

/// Enum type information
struct EnumType {
    name: String,
    variant_count: i32
}

/// Function type
struct FunctionType {
    param_count: i32,
    return_type_id: i32
}

/// Array type
struct ArrayType {
    element_type_id: i32,
    size: i32
}

/// Pointer type
struct PointerType {
    pointee_type_id: i32
}

/// Reference type
struct ReferenceType {
    referenced_type_id: i32,
    is_mutable: bool
}

/// Type variable for inference
struct TypeVar {
    id: i32,
    name: String
}

// ============================================================================
// TYPE ENVIRONMENT
// ============================================================================

/// Type binding (name to type)
struct TypeBinding {
    name: String,
    type_id: i32,
    defined_at: Span
}

/// Type environment (symbol table for types)
struct TypeEnvironment {
    bindings: Vec<TypeBinding>,
    binding_count: i32
}

// ============================================================================
// TYPE CONSTRAINTS
// ============================================================================

/// Type constraint (for unification)
struct TypeConstraint {
    left_type_id: i32,
    right_type_id: i32,
    reason: String,
    span: Span
}

// ============================================================================
// TYPE CHECKER STATE
// ============================================================================

/// Type checker state
struct TypeChecker {
    type_env: TypeEnvironment,
    constraints: Vec<TypeConstraint>,
    constraint_count: i32,
    next_type_var: i32,
    errors: Vec<TypeError>,
    error_count: i32
}

/// Type error
struct TypeError {
    message: String,
    span: Span,
    expected_type_id: i32,
    actual_type_id: i32
}

/// Result of type checking
struct TypeCheckResult {
    checker: TypeChecker,
    success: bool,
    inferred_type_id: i32
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/// Create a dummy span
fn dummy_span_tc() -> Span {
    let empty = "";
    Span {
        file: empty,
        line: 0,
        column: 0,
        start: 0,
        length: 0
    }
}

/// Create a new type binding
fn new_type_binding(name: String, type_id: i32, span: Span) -> TypeBinding {
    TypeBinding {
        name: name,
        type_id: type_id,
        defined_at: span
    }
}

/// Create a new type constraint
fn new_constraint(left: i32, right: i32, reason: String, span: Span) -> TypeConstraint {
    TypeConstraint {
        left_type_id: left,
        right_type_id: right,
        reason: reason,
        span: span
    }
}

/// Create a new type error
fn new_type_error(message: String, span: Span, expected: i32, actual: i32) -> TypeError {
    TypeError {
        message: message,
        span: span,
        expected_type_id: expected,
        actual_type_id: actual
    }
}

/// Create a new type environment
fn new_type_environment() -> TypeEnvironment {
    TypeEnvironment {
        bindings: Vec::new(),
        binding_count: 0
    }
}

// ============================================================================
// TYPE CHECKER INITIALIZATION
// ============================================================================

/// Create a new type checker
fn new_type_checker() -> TypeChecker {
    TypeChecker {
        type_env: new_type_environment(),
        constraints: Vec::new(),
        constraint_count: 0,
        next_type_var: 0,
        errors: Vec::new(),
        error_count: 0
    }
}

// ============================================================================
// TYPE VARIABLE GENERATION
// ============================================================================

/// Result of fresh type variable generation
struct FreshTypeVarResult {
    checker: TypeChecker,
    type_var_id: i32
}

/// Generate a fresh type variable
fn fresh_type_var(mut checker: TypeChecker) -> FreshTypeVarResult {
    let var_id = checker.next_type_var;
    checker.next_type_var = checker.next_type_var + 1;
    
    FreshTypeVarResult {
        checker: checker,
        type_var_id: var_id
    }
}

// ============================================================================
// TYPE ENVIRONMENT OPERATIONS
// ============================================================================

/// Add a type binding to environment
fn add_type_binding(mut env: TypeEnvironment, name: String, type_id: i32, span: Span) -> TypeEnvironment {
    let binding = new_type_binding(name, type_id, span);
    env.binding_count = env.binding_count + 1;
    // In actual implementation, would push binding to bindings vector
    env
}

/// Look up a type by name
fn lookup_type(env: TypeEnvironment, name: String) -> i32 {
    // In actual implementation, would search bindings
    // For now, return -1 (not found)
    -1
}

/// Check if type is defined
fn is_type_defined(env: TypeEnvironment, name: String) -> bool {
    let type_id = lookup_type(env, name);
    type_id != -1
}

// ============================================================================
// CONSTRAINT GENERATION
// ============================================================================

/// Add a type constraint
fn add_constraint(mut checker: TypeChecker, left: i32, right: i32, reason: String, span: Span) -> TypeChecker {
    let constraint = new_constraint(left, right, reason, span);
    checker.constraint_count = checker.constraint_count + 1;
    // In actual implementation, would push to constraints vector
    checker
}

/// Generate equality constraint (type1 == type2)
fn generate_equality_constraint(mut checker: TypeChecker, type1: i32, type2: i32, span: Span) -> TypeChecker {
    let reason = String::from("types must be equal");
    add_constraint(checker, type1, type2, reason, span)
}

// ============================================================================
// TYPE INFERENCE FOR LITERALS
// ============================================================================

/// Infer type of integer literal
fn infer_int_literal(checker: TypeChecker, value: String) -> TypeCheckResult {
    // Default to i32 for integer literals
    // Type ID 0 = i32 by convention
    TypeCheckResult {
        checker: checker,
        success: true,
        inferred_type_id: 0
    }
}

/// Infer type of float literal
fn infer_float_literal(checker: TypeChecker, value: String) -> TypeCheckResult {
    // Default to f64 for float literals
    // Type ID 1 = f64 by convention
    TypeCheckResult {
        checker: checker,
        success: true,
        inferred_type_id: 1
    }
}

/// Infer type of bool literal
fn infer_bool_literal(checker: TypeChecker, value: bool) -> TypeCheckResult {
    // Type ID 2 = bool by convention
    TypeCheckResult {
        checker: checker,
        success: true,
        inferred_type_id: 2
    }
}

/// Infer type of string literal
fn infer_string_literal(checker: TypeChecker, value: String) -> TypeCheckResult {
    // Type ID 3 = String by convention
    TypeCheckResult {
        checker: checker,
        success: true,
        inferred_type_id: 3
    }
}

/// Infer type of char literal
fn infer_char_literal(checker: TypeChecker, value: char) -> TypeCheckResult {
    // Type ID 4 = char by convention
    TypeCheckResult {
        checker: checker,
        success: true,
        inferred_type_id: 4
    }
}

// ============================================================================
// TYPE INFERENCE FOR EXPRESSIONS
// ============================================================================

/// Infer type of variable reference
fn infer_variable(mut checker: TypeChecker, name: String, span: Span) -> TypeCheckResult {
    // Look up variable type in environment
    let type_id = lookup_type(checker.type_env, name);
    
    if type_id == -1 {
        // Variable not found - error
        let error_msg = String::from("Undefined variable");
        let error = new_type_error(error_msg, span, -1, -1);
        checker.error_count = checker.error_count + 1;
        
        TypeCheckResult {
            checker: checker,
            success: false,
            inferred_type_id: -1
        }
    } else {
        TypeCheckResult {
            checker: checker,
            success: true,
            inferred_type_id: type_id
        }
    }
}

/// Infer type of binary operation
fn infer_binary_op(mut checker: TypeChecker, op: String, left_type: i32, right_type: i32, span: Span) -> TypeCheckResult {
    // Generate constraint that operands match
    let reason = String::from("binary op operands must match");
    checker = add_constraint(checker, left_type, right_type, reason, span);
    
    // Result type depends on operator
    // For arithmetic: same as operands
    // For comparison: bool (type ID 2)
    
    // Simplified: return left type
    TypeCheckResult {
        checker: checker,
        success: true,
        inferred_type_id: left_type
    }
}

/// Infer type of function call
fn infer_function_call(mut checker: TypeChecker, func_type: i32, arg_types: Vec<i32>, span: Span) -> TypeCheckResult {
    // In actual implementation, would:
    // 1. Check func_type is a function type
    // 2. Check argument count matches
    // 3. Generate constraints for each parameter
    // 4. Return return type of function
    
    // For now, return fresh type variable
    let fresh = fresh_type_var(checker);
    
    TypeCheckResult {
        checker: fresh.checker,
        success: true,
        inferred_type_id: fresh.type_var_id
    }
}

/// Infer type of if expression
fn infer_if_expr(mut checker: TypeChecker, cond_type: i32, then_type: i32, else_type: i32, span: Span) -> TypeCheckResult {
    // Condition must be bool (type ID 2)
    let reason_cond = String::from("if condition must be bool");
    checker = add_constraint(checker, cond_type, 2, reason_cond, span);
    
    // Then and else branches must have same type
    let reason_branches = String::from("if branches must have same type");
    checker = add_constraint(checker, then_type, else_type, reason_branches, span);
    
    // Result is type of then branch
    TypeCheckResult {
        checker: checker,
        success: true,
        inferred_type_id: then_type
    }
}

// ============================================================================
// TYPE CHECKING FOR DECLARATIONS
// ============================================================================

/// Type check a function declaration
fn check_function_decl(mut checker: TypeChecker, name: String, param_types: Vec<i32>, return_type: i32, span: Span) -> TypeChecker {
    // Add function to type environment
    // Function type ID would be computed from params and return type
    // For now, use return type as approximation
    checker.type_env = add_type_binding(checker.type_env, name, return_type, span);
    
    checker
}

/// Type check a variable declaration
fn check_variable_decl(mut checker: TypeChecker, name: String, declared_type: i32, init_type: i32, span: Span) -> TypeChecker {
    // Generate constraint that declared type matches initializer type
    let reason = String::from("variable type must match initializer");
    checker = add_constraint(checker, declared_type, init_type, reason, span);
    
    // Add variable to type environment
    checker.type_env = add_type_binding(checker.type_env, name, declared_type, span);
    
    checker
}

/// Type check a struct declaration
fn check_struct_decl(mut checker: TypeChecker, name: String, field_count: i32, span: Span) -> TypeChecker {
    // Add struct type to environment
    // Struct type ID would be unique
    // For now, use field_count as type ID (simplified)
    checker.type_env = add_type_binding(checker.type_env, name, field_count, span);
    
    checker
}

// ============================================================================
// UNIFICATION
// ============================================================================

/// Unification result
struct UnifyResult {
    checker: TypeChecker,
    success: bool
}

/// Unify two types (make them equal)
fn unify_types(mut checker: TypeChecker, type1: i32, type2: i32) -> UnifyResult {
    // In actual implementation, would:
    // 1. Check if types are already equal
    // 2. If one is type variable, bind it to the other
    // 3. If both are compound types, recursively unify components
    // 4. Otherwise, fail with type error
    
    // Simplified: always succeed if not negative
    let success = type1 >= 0 && type2 >= 0;
    
    UnifyResult {
        checker: checker,
        success: success
    }
}

/// Solve all constraints
fn solve_constraints(mut checker: TypeChecker) -> TypeChecker {
    // In actual implementation, would:
    // 1. Iterate through all constraints
    // 2. Unify types for each constraint
    // 3. Propagate substitutions
    // 4. Report errors for failed unifications
    
    // For now, just return checker
    checker
}

// ============================================================================
// MODULE TYPE CHECKING
// ============================================================================

/// Type check a module
fn type_check_module(mut checker: TypeChecker) -> TypeCheckResult {
    // Solve all generated constraints
    checker = solve_constraints(checker);
    
    // Success if no errors
    let success = checker.error_count == 0;
    
    TypeCheckResult {
        checker: checker,
        success: success,
        inferred_type_id: -1
    }
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/// Get error count
fn get_type_error_count(checker: TypeChecker) -> i32 {
    checker.error_count
}

/// Check if type checker has errors
fn has_type_errors(checker: TypeChecker) -> bool {
    checker.error_count > 0
}

/// Get constraint count
fn get_constraint_count(checker: TypeChecker) -> i32 {
    checker.constraint_count
}

/// Get next type variable ID
fn get_next_type_var_id(checker: TypeChecker) -> i32 {
    checker.next_type_var
}

// ============================================================================
// BACKWARD COMPATIBILITY
// ============================================================================

// Old AsterType enum for backward compatibility
enum AsterType {
    I32,
    I64,
    Bool,
    String,
    Void,
    Unknown
}

// Old Symbol struct for backward compatibility
struct Symbol {
    name: String,
    symbol_type: AsterType,
    is_function: bool
}

// Old SymbolTable for backward compatibility
struct SymbolTable {
    symbols: Vec<Symbol>,
    symbol_count: i32
}

/// Create a new symbol table (old API)
fn new_symbol_table() -> SymbolTable {
    SymbolTable {
        symbols: Vec::new(),
        symbol_count: 0
    }
}

/// Add a symbol to the table (old API)
fn add_symbol(mut st: SymbolTable, name: String, sym_type: AsterType, is_func: bool) -> SymbolTable {
    let symbol = Symbol {
        name: name,
        symbol_type: sym_type,
        is_function: is_func
    };
    
    st.symbol_count = st.symbol_count + 1;
    st
}

/// Look up a symbol (old API)
fn lookup_symbol(st: SymbolTable, name: String) -> AsterType {
    AsterType::I32
}

/// Check if two types are compatible (old API)
fn types_compatible(t1: AsterType, t2: AsterType) -> bool {
    true
}

/// Infer type of a literal (old API)
fn infer_literal_type(value: String) -> AsterType {
    AsterType::I32
}
