// Type Checking - Implementation for Stage 1
// Part of Aster Stage 1 (Core-0 implementation)
//
// This module implements type checking and type inference for Aster programs.
// It uses a simplified Hindley-Milner style type inference with constraints.
//
// Language Subset: Core-0
// - Uses only: structs, enums, Vec, String, functions
// - No traits, no HashMap, no methods
// - All functions are standalone

// ============================================================================
// EMBEDDED DEPENDENCIES (for self-contained compilation)
// ============================================================================

/// Generic vector type (provided by runtime)
struct Vec<T> {}

/// Boxed pointer type (provided by runtime)
struct Box<T> {}

/// Source location span within a file
struct Span {
    file: String,
    line: i32,
    column: i32,
    start: i32,
    length: i32
}

// ============================================================================
// TYPE REPRESENTATION
// ============================================================================

/// Primitive type kinds
enum PrimitiveType {
    I32,
    I64,
    U32,
    U64,
    F32,
    F64,
    Bool,
    Char,
    String,
    Void
}

/// Complete type representation
enum Type {
    Primitive(PrimitiveType),
    Struct(StructType),
    Enum(EnumType),
    Function(FunctionType),
    Array(ArrayType),
    Pointer(PointerType),
    Reference(ReferenceType),
    TypeVariable(TypeVar),
    Unknown,
    Error
}

/// Struct type information
struct StructType {
    name: String,
    field_count: i32
}

/// Enum type information
struct EnumType {
    name: String,
    variant_count: i32
}

/// Function type
struct FunctionType {
    param_count: i32,
    return_type_id: i32
}

/// Array type
struct ArrayType {
    element_type_id: i32,
    size: i32
}

/// Pointer type
struct PointerType {
    pointee_type_id: i32
}

/// Reference type
struct ReferenceType {
    referenced_type_id: i32,
    is_mutable: bool
}

/// Type variable for inference
struct TypeVar {
    id: i32,
    name: String
}

// ============================================================================
// TYPE ENVIRONMENT
// ============================================================================

/// Type binding (name to type)
struct TypeBinding {
    name: String,
    type_id: i32,
    defined_at: Span
}

/// Type environment (symbol table for types)
struct TypeEnvironment {
    bindings: Vec<TypeBinding>,
    binding_count: i32
}

// ============================================================================
// TYPE CONSTRAINTS
// ============================================================================

/// Type constraint (for unification)
struct TypeConstraint {
    left_type_id: i32,
    right_type_id: i32,
    reason: String,
    span: Span
}

// ============================================================================
// TYPE CHECKER STATE
// ============================================================================

/// Type checker state
struct TypeChecker {
    type_env: TypeEnvironment,
    constraints: Vec<TypeConstraint>,
    constraint_count: i32,
    next_type_var: i32,
    errors: Vec<TypeError>,
    error_count: i32
}

/// Type error
struct TypeError {
    message: String,
    span: Span,
    expected_type_id: i32,
    actual_type_id: i32
}

/// Result of type checking
struct TypeCheckResult {
    checker: TypeChecker,
    success: bool,
    inferred_type_id: i32
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/// Create a dummy span
fn dummy_span_tc() -> Span {
    let empty = "";
    Span {
        file: empty,
        line: 0,
        column: 0,
        start: 0,
        length: 0
    }
}

/// Create a new type binding
fn new_type_binding(name: String, type_id: i32, span: Span) -> TypeBinding {
    TypeBinding {
        name: name,
        type_id: type_id,
        defined_at: span
    }
}

/// Create a new type constraint
fn new_constraint(left: i32, right: i32, reason: String, span: Span) -> TypeConstraint {
    TypeConstraint {
        left_type_id: left,
        right_type_id: right,
        reason: reason,
        span: span
    }
}

/// Create a new type error
fn new_type_error(message: String, span: Span, expected: i32, actual: i32) -> TypeError {
    TypeError {
        message: message,
        span: span,
        expected_type_id: expected,
        actual_type_id: actual
    }
}

/// Create a new type environment
fn new_type_environment() -> TypeEnvironment {
    TypeEnvironment {
        bindings: Vec::new(),
        binding_count: 0
    }
}

// ============================================================================
// TYPE CHECKER INITIALIZATION
// ============================================================================

/// Create a new type checker
fn new_type_checker() -> TypeChecker {
    TypeChecker {
        type_env: new_type_environment(),
        constraints: Vec::new(),
        constraint_count: 0,
        next_type_var: 0,
        errors: Vec::new(),
        error_count: 0
    }
}

// ============================================================================
// TYPE VARIABLE GENERATION
// ============================================================================

/// Result of fresh type variable generation
struct FreshTypeVarResult {
    checker: TypeChecker,
    type_var_id: i32
}

/// Generate a fresh type variable
fn fresh_type_var(mut checker: TypeChecker) -> FreshTypeVarResult {
    let var_id = checker.next_type_var;
    checker.next_type_var = checker.next_type_var + 1;
    
    FreshTypeVarResult {
        checker: checker,
        type_var_id: var_id
    }
}

// ============================================================================
// TYPE ENVIRONMENT OPERATIONS
// ============================================================================

/// Add a type binding to environment
fn add_type_binding(mut env: TypeEnvironment, name: String, type_id: i32, span: Span) -> TypeEnvironment {
    let binding = new_type_binding(name, type_id, span);
    env.binding_count = env.binding_count + 1;
    // In actual implementation, would push binding to bindings vector
    env
}

/// Look up a type by name
fn lookup_type(env: TypeEnvironment, name: String) -> i32 {
    // In actual implementation, would search bindings
    // For now, return -1 (not found)
    -1
}

/// Check if type is defined
fn is_type_defined(env: TypeEnvironment, name: String) -> bool {
    let type_id = lookup_type(env, name);
    type_id != -1
}

// ============================================================================
// CONSTRAINT GENERATION
// ============================================================================

/// Add a type constraint
fn add_constraint(mut checker: TypeChecker, left: i32, right: i32, reason: String, span: Span) -> TypeChecker {
    let constraint = new_constraint(left, right, reason, span);
    checker.constraint_count = checker.constraint_count + 1;
    // In actual implementation, would push to constraints vector
    checker
}

/// Generate equality constraint (type1 == type2)
fn generate_equality_constraint(mut checker: TypeChecker, type1: i32, type2: i32, span: Span) -> TypeChecker {
    let reason = String::from("types must be equal");
    add_constraint(checker, type1, type2, reason, span)
}

// ============================================================================
// TYPE INFERENCE FOR LITERALS
// ============================================================================

/// Infer type of integer literal
fn infer_int_literal(checker: TypeChecker, value: String) -> TypeCheckResult {
    // Default to i32 for integer literals
    // Type ID 0 = i32 by convention
    TypeCheckResult {
        checker: checker,
        success: true,
        inferred_type_id: 0
    }
}

/// Infer type of float literal
fn infer_float_literal(checker: TypeChecker, value: String) -> TypeCheckResult {
    // Default to f64 for float literals
    // Type ID 1 = f64 by convention
    TypeCheckResult {
        checker: checker,
        success: true,
        inferred_type_id: 1
    }
}

/// Infer type of bool literal
fn infer_bool_literal(checker: TypeChecker, value: bool) -> TypeCheckResult {
    // Type ID 2 = bool by convention
    TypeCheckResult {
        checker: checker,
        success: true,
        inferred_type_id: 2
    }
}

/// Infer type of string literal
fn infer_string_literal(checker: TypeChecker, value: String) -> TypeCheckResult {
    // Type ID 3 = String by convention
    TypeCheckResult {
        checker: checker,
        success: true,
        inferred_type_id: 3
    }
}

/// Infer type of char literal
fn infer_char_literal(checker: TypeChecker, value: char) -> TypeCheckResult {
    // Type ID 4 = char by convention
    TypeCheckResult {
        checker: checker,
        success: true,
        inferred_type_id: 4
    }
}

// ============================================================================
// TYPE INFERENCE FOR EXPRESSIONS
// ============================================================================

/// Infer type of variable reference
fn infer_variable(mut checker: TypeChecker, name: String, span: Span) -> TypeCheckResult {
    // Look up variable type in environment
    let type_id = lookup_type(checker.type_env, name);
    
    if type_id == -1 {
        // Variable not found - error
        let error_msg = String::from("Undefined variable");
        let error = new_type_error(error_msg, span, -1, -1);
        checker.error_count = checker.error_count + 1;
        
        TypeCheckResult {
            checker: checker,
            success: false,
            inferred_type_id: -1
        }
    } else {
        TypeCheckResult {
            checker: checker,
            success: true,
            inferred_type_id: type_id
        }
    }
}

/// Infer type of binary operation
fn infer_binary_op(mut checker: TypeChecker, op: String, left_type: i32, right_type: i32, span: Span) -> TypeCheckResult {
    // Generate constraint that operands match
    let reason = String::from("binary op operands must match");
    checker = add_constraint(checker, left_type, right_type, reason, span);
    
    // Result type depends on operator
    // For arithmetic: same as operands
    // For comparison: bool (type ID 2)
    
    // Simplified: return left type
    TypeCheckResult {
        checker: checker,
        success: true,
        inferred_type_id: left_type
    }
}

/// Infer type of function call
fn infer_function_call(mut checker: TypeChecker, func_type: i32, arg_types: Vec<i32>, span: Span) -> TypeCheckResult {
    // In actual implementation, would:
    // 1. Check func_type is a function type
    // 2. Check argument count matches
    // 3. Generate constraints for each parameter
    // 4. Return return type of function
    
    // For now, return fresh type variable
    let fresh = fresh_type_var(checker);
    
    TypeCheckResult {
        checker: fresh.checker,
        success: true,
        inferred_type_id: fresh.type_var_id
    }
}

/// Infer type of if expression
fn infer_if_expr(mut checker: TypeChecker, cond_type: i32, then_type: i32, else_type: i32, span: Span) -> TypeCheckResult {
    // Condition must be bool (type ID 2)
    let reason_cond = String::from("if condition must be bool");
    checker = add_constraint(checker, cond_type, 2, reason_cond, span);
    
    // Then and else branches must have same type
    let reason_branches = String::from("if branches must have same type");
    checker = add_constraint(checker, then_type, else_type, reason_branches, span);
    
    // Result is type of then branch
    TypeCheckResult {
        checker: checker,
        success: true,
        inferred_type_id: then_type
    }
}

/// Infer type of while loop
fn infer_while_loop(mut checker: TypeChecker, cond_type: i32, body_type: i32, span: Span) -> TypeCheckResult {
    // Condition must be bool
    let reason = String::from("while condition must be bool");
    checker = add_constraint(checker, cond_type, 2, reason, span);
    
    // While loop returns void (type ID 9)
    TypeCheckResult {
        checker: checker,
        success: true,
        inferred_type_id: 9
    }
}

/// Infer type of for loop
fn infer_for_loop(mut checker: TypeChecker, iter_type: i32, body_type: i32, span: Span) -> TypeCheckResult {
    // For loop returns void (type ID 9)
    // In full implementation, would check iter_type is iterable
    TypeCheckResult {
        checker: checker,
        success: true,
        inferred_type_id: 9
    }
}

/// Infer type of block expression
fn infer_block(mut checker: TypeChecker, stmt_types: Vec<i32>, final_expr_type: i32) -> TypeCheckResult {
    // Block type is the type of its final expression
    // If no final expression, type is void (type ID 9)
    let result_type = if final_expr_type >= 0 { final_expr_type } else { 9 };
    
    TypeCheckResult {
        checker: checker,
        success: true,
        inferred_type_id: result_type
    }
}

/// Infer type of assignment
fn infer_assignment(mut checker: TypeChecker, lhs_type: i32, rhs_type: i32, span: Span) -> TypeCheckResult {
    // Left and right sides must have same type
    let reason = String::from("assignment types must match");
    checker = add_constraint(checker, lhs_type, rhs_type, reason, span);
    
    // Assignment returns void (type ID 9)
    TypeCheckResult {
        checker: checker,
        success: true,
        inferred_type_id: 9
    }
}

/// Infer type of struct construction
fn infer_struct_construction(mut checker: TypeChecker, struct_type_id: i32, field_types: Vec<i32>, span: Span) -> TypeCheckResult {
    // In full implementation, would check that:
    // 1. struct_type_id is a valid struct
    // 2. All required fields are present
    // 3. Field types match struct definition
    
    // For now, return the struct type
    TypeCheckResult {
        checker: checker,
        success: true,
        inferred_type_id: struct_type_id
    }
}

/// Infer type of enum variant construction
fn infer_enum_construction(mut checker: TypeChecker, enum_type_id: i32, variant_types: Vec<i32>, span: Span) -> TypeCheckResult {
    // In full implementation, would check that:
    // 1. enum_type_id is a valid enum
    // 2. Variant exists
    // 3. Associated data types match
    
    // For now, return the enum type
    TypeCheckResult {
        checker: checker,
        success: true,
        inferred_type_id: enum_type_id
    }
}

/// Infer type of array literal
fn infer_array_literal(mut checker: TypeChecker, element_types: Vec<i32>, span: Span) -> TypeCheckResult {
    // All elements must have same type
    // In full implementation, would iterate and constrain all elements
    
    // If no elements, return unknown array type
    // If elements exist, constrain them all to be equal and return array type
    
    // For now, return fresh type variable for array
    let fresh = fresh_type_var(checker);
    
    TypeCheckResult {
        checker: fresh.checker,
        success: true,
        inferred_type_id: fresh.type_var_id
    }
}

/// Infer type of index expression (array[index])
fn infer_index_expr(mut checker: TypeChecker, array_type: i32, index_type: i32, span: Span) -> TypeCheckResult {
    // Index must be integer type (i32, type ID 0)
    let reason = String::from("array index must be integer");
    checker = add_constraint(checker, index_type, 0, reason, span);
    
    // Result type is element type of array
    // In full implementation, would extract element type from array_type
    // For now, return fresh type variable
    let fresh = fresh_type_var(checker);
    
    TypeCheckResult {
        checker: fresh.checker,
        success: true,
        inferred_type_id: fresh.type_var_id
    }
}

/// Infer type of field access (struct.field)
fn infer_field_access_expr(mut checker: TypeChecker, struct_type: i32, field_name: String, span: Span) -> TypeCheckResult {
    // In full implementation, would:
    // 1. Check struct_type is a struct
    // 2. Look up field in struct definition
    // 3. Return field's type
    
    // For now, return fresh type variable
    let fresh = fresh_type_var(checker);
    
    TypeCheckResult {
        checker: fresh.checker,
        success: true,
        inferred_type_id: fresh.type_var_id
    }
}

/// Infer type of method call
fn infer_method_call(mut checker: TypeChecker, receiver_type: i32, method_name: String, arg_types: Vec<i32>, span: Span) -> TypeCheckResult {
    // In full implementation, would:
    // 1. Look up method in receiver type
    // 2. Check argument types against method signature
    // 3. Return method return type
    
    // For now, return fresh type variable
    let fresh = fresh_type_var(checker);
    
    TypeCheckResult {
        checker: fresh.checker,
        success: true,
        inferred_type_id: fresh.type_var_id
    }
}

// ============================================================================
// PATTERN MATCHING AND MATCH EXPRESSIONS
// ============================================================================

/// Pattern type information
struct PatternType {
    pattern_type_id: i32,
    bindings: Vec<TypeBinding>,
    binding_count: i32
}

/// Create pattern type
fn new_pattern_type(type_id: i32) -> PatternType {
    PatternType {
        pattern_type_id: type_id,
        bindings: Vec::new(),
        binding_count: 0
    }
}

/// Type check a pattern
fn check_pattern(mut checker: TypeChecker, pattern_type: i32, scrutinee_type: i32, span: Span) -> TypeChecker {
    // Pattern type must match scrutinee type
    let reason = String::from("pattern must match scrutinee type");
    checker = add_constraint(checker, pattern_type, scrutinee_type, reason, span);
    
    // In full implementation, would:
    // 1. Extract bindings from pattern
    // 2. Add bindings to type environment
    // 3. Check pattern exhaustiveness
    
    checker
}

/// Infer type of match expression
fn infer_match_expr(mut checker: TypeChecker, scrutinee_type: i32, arm_types: Vec<i32>, span: Span) -> TypeCheckResult {
    // All arms must have the same type
    // In full implementation, would iterate through arms and constrain them
    
    // For now, if we have arms, return type of first arm
    // Otherwise, return void
    let result_type = 9;  // void
    
    TypeCheckResult {
        checker: checker,
        success: true,
        inferred_type_id: result_type
    }
}

/// Check match arm exhaustiveness
fn check_match_exhaustive(checker: TypeChecker, scrutinee_type: i32, patterns: Vec<i32>) -> bool {
    // In full implementation, would check that patterns cover all cases
    // For enum: all variants covered
    // For bool: true and false covered
    // For integers: wildcard pattern present
    
    // For now, assume exhaustive
    true
}

// ============================================================================
// TYPE CHECKING FOR DECLARATIONS
// ============================================================================

/// Type check a function declaration
fn check_function_decl(mut checker: TypeChecker, name: String, param_types: Vec<i32>, return_type: i32, span: Span) -> TypeChecker {
    // Add function to type environment
    // Function type ID would be computed from params and return type
    // For now, use return type as approximation
    checker.type_env = add_type_binding(checker.type_env, name, return_type, span);
    
    checker
}

/// Type check a variable declaration
fn check_variable_decl(mut checker: TypeChecker, name: String, declared_type: i32, init_type: i32, span: Span) -> TypeChecker {
    // Generate constraint that declared type matches initializer type
    let reason = String::from("variable type must match initializer");
    checker = add_constraint(checker, declared_type, init_type, reason, span);
    
    // Add variable to type environment
    checker.type_env = add_type_binding(checker.type_env, name, declared_type, span);
    
    checker
}

/// Type check a struct declaration
fn check_struct_decl(mut checker: TypeChecker, name: String, field_count: i32, span: Span) -> TypeChecker {
    // Add struct type to environment
    // Struct type ID would be unique
    // For now, use field_count as type ID (simplified)
    checker.type_env = add_type_binding(checker.type_env, name, field_count, span);
    
    checker
}

// ============================================================================
// TYPE SUBSTITUTION
// ============================================================================

/// Type substitution (maps type variable to concrete type)
struct Substitution {
    from_type_id: i32,
    to_type_id: i32
}

/// Create a new substitution
fn new_substitution(from: i32, to: i32) -> Substitution {
    Substitution {
        from_type_id: from,
        to_type_id: to
    }
}

/// Apply substitutions to a type ID
fn apply_substitution(type_id: i32, substitutions: Vec<Substitution>) -> i32 {
    // In actual implementation, would iterate through substitutions
    // and apply them to the type_id
    // For now, just return the type_id unchanged
    type_id
}

/// Compose two substitutions
fn compose_substitutions(mut s1: Vec<Substitution>, s2: Vec<Substitution>) -> Vec<Substitution> {
    // In actual implementation, would apply s2 to all types in s1
    // then append s2 to s1
    // For now, just return s1
    s1
}

/// Add a substitution to checker
fn add_substitution(mut checker: TypeChecker, from: i32, to: i32) -> TypeChecker {
    // In actual implementation, would add to substitution list
    // For now, just return checker
    checker
}

// ============================================================================
// UNIFICATION
// ============================================================================

/// Unification result
struct UnifyResult {
    checker: TypeChecker,
    success: bool
}

/// Check if two type IDs are equal
fn types_equal(type1: i32, type2: i32) -> bool {
    type1 == type2
}

/// Check if type ID is a type variable
fn is_type_variable(type_id: i32) -> bool {
    // Type variables have IDs >= 1000 by convention
    type_id >= 1000
}

/// Unify two types (make them equal)
fn unify_types(mut checker: TypeChecker, type1: i32, type2: i32) -> UnifyResult {
    // 1. If types are already equal, unification succeeds
    if types_equal(type1, type2) {
        return UnifyResult {
            checker: checker,
            success: true
        };
    }
    
    // 2. If type1 is a type variable, bind it to type2
    if is_type_variable(type1) {
        checker = add_substitution(checker, type1, type2);
        return UnifyResult {
            checker: checker,
            success: true
        };
    }
    
    // 3. If type2 is a type variable, bind it to type1
    if is_type_variable(type2) {
        checker = add_substitution(checker, type2, type1);
        return UnifyResult {
            checker: checker,
            success: true
        };
    }
    
    // 4. For compound types, would recursively unify components
    // For primitive types that don't match, unification fails
    
    // 5. Both are concrete types but different - fail
    if type1 >= 0 && type2 >= 0 && type1 != type2 {
        // Add type error
        let error_msg = String::from("Type mismatch in unification");
        let dummy = dummy_span_tc();
        let error = new_type_error(error_msg, dummy, type1, type2);
        checker.error_count = checker.error_count + 1;
        
        return UnifyResult {
            checker: checker,
            success: false
        };
    }
    
    // 6. Unknown or error types - fail gracefully
    UnifyResult {
        checker: checker,
        success: false
    }
}

/// Type pair for unification
struct TypePair {
    first: i32,
    second: i32
}

/// Create a type pair
fn new_type_pair(first: i32, second: i32) -> TypePair {
    TypePair {
        first: first,
        second: second
    }
}

/// Unify multiple type pairs
fn unify_types_list(mut checker: TypeChecker, pairs: Vec<TypePair>) -> UnifyResult {
    // In actual implementation, would iterate through pairs
    // and unify each one
    // For now, just succeed
    UnifyResult {
        checker: checker,
        success: true
    }
}

/// Solve all constraints
fn solve_constraints(mut checker: TypeChecker) -> TypeChecker {
    // In actual implementation, would:
    // 1. Iterate through all constraints in checker.constraints
    // 2. For each constraint, unify left_type_id and right_type_id
    // 3. If unification fails, add error with constraint.reason and constraint.span
    // 4. Propagate substitutions to remaining constraints
    
    // Simplified implementation:
    // Just mark that constraints were processed
    // In real implementation, would iterate through constraint_count constraints
    
    // For demonstration, if we had constraints, we'd unify them:
    // let i = 0;
    // while i < checker.constraint_count {
    //     // Get constraint at index i
    //     // let result = unify_types(checker, constraint.left, constraint.right);
    //     // checker = result.checker;
    //     // if !result.success {
    //     //     // Error already added by unify_types
    //     // }
    //     i = i + 1;
    // }
    
    checker
}

// ============================================================================
// MODULE TYPE CHECKING
// ============================================================================

/// Type check a module
fn type_check_module(mut checker: TypeChecker) -> TypeCheckResult {
    // Solve all generated constraints
    checker = solve_constraints(checker);
    
    // Success if no errors
    let success = checker.error_count == 0;
    
    TypeCheckResult {
        checker: checker,
        success: success,
        inferred_type_id: -1
    }
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/// Get error count
fn get_type_error_count(checker: TypeChecker) -> i32 {
    checker.error_count
}

/// Check if type checker has errors
fn has_type_errors(checker: TypeChecker) -> bool {
    checker.error_count > 0
}

/// Get constraint count
fn get_constraint_count(checker: TypeChecker) -> i32 {
    checker.constraint_count
}

/// Get next type variable ID
fn get_next_type_var_id(checker: TypeChecker) -> i32 {
    checker.next_type_var
}

// ============================================================================
// TYPE DISPLAY AND ERROR MESSAGES
// ============================================================================

/// Convert type ID to string representation
fn type_id_to_string(type_id: i32) -> String {
    // In full implementation, would look up actual type info
    // and format it properly
    
    if type_id == 0 { return String::from("i32"); }
    if type_id == 1 { return String::from("f64"); }
    if type_id == 2 { return String::from("bool"); }
    if type_id == 3 { return String::from("String"); }
    if type_id == 4 { return String::from("char"); }
    if type_id == 5 { return String::from("i64"); }
    if type_id == 6 { return String::from("u32"); }
    if type_id == 7 { return String::from("u64"); }
    if type_id == 8 { return String::from("f32"); }
    if type_id == 9 { return String::from("void"); }
    
    if type_id >= 1000 {
        // Type variable
        return String::from("T");
    }
    
    if type_id < 0 {
        return String::from("<unknown>");
    }
    
    // Other types
    String::from("<type>")
}

/// Create a detailed type error message
fn format_type_error(expected: i32, actual: i32, context: String) -> String {
    let expected_str = type_id_to_string(expected);
    let actual_str = type_id_to_string(actual);
    
    // Simplified string concatenation for Core-0
    // In real implementation, would use proper string formatting
    let msg = String::from("Type mismatch");
    msg
}

/// Add a type error with detailed message
fn add_type_error_detailed(mut checker: TypeChecker, expected: i32, actual: i32, context: String, span: Span) -> TypeChecker {
    let message = format_type_error(expected, actual, context);
    let error = new_type_error(message, span, expected, actual);
    checker.error_count = checker.error_count + 1;
    checker
}

/// Suggest a fix for a type error
fn suggest_fix_for_type_error(expected: i32, actual: i32) -> String {
    // In full implementation, would provide helpful suggestions like:
    // - "Did you mean to call .to_string()?"
    // - "Try adding a type cast"
    // - "Consider using a different operator"
    
    String::from("")
}

/// Check if types are compatible (with coercion)
fn types_compatible_with_coercion(type1: i32, type2: i32) -> bool {
    // Check if types are exactly equal
    if type1 == type2 {
        return true;
    }
    
    // Check for numeric type coercions
    // i32 (0) can coerce to i64 (5)
    if type1 == 0 && type2 == 5 {
        return true;
    }
    
    // u32 (6) can coerce to u64 (7)
    if type1 == 6 && type2 == 7 {
        return true;
    }
    
    // f32 (8) can coerce to f64 (1)
    if type1 == 8 && type2 == 1 {
        return true;
    }
    
    // Type variables can unify with anything
    if is_type_variable(type1) || is_type_variable(type2) {
        return true;
    }
    
    false
}

/// Format a list of types
fn format_type_list(types: Vec<i32>) -> String {
    // In full implementation, would format as: "(i32, bool, String)"
    String::from("<types>")
}

/// Display constraint information
fn format_constraint(constraint: TypeConstraint) -> String {
    let left_str = type_id_to_string(constraint.left_type_id);
    let right_str = type_id_to_string(constraint.right_type_id);
    
    // Would format as: "i32 == bool (reason: binary op operands)"
    String::from("<constraint>")
}

// ============================================================================
// BACKWARD COMPATIBILITY
// ============================================================================

// Old AsterType enum for backward compatibility
enum AsterType {
    I32,
    I64,
    Bool,
    String,
    Void,
    Unknown
}

// Old Symbol struct for backward compatibility
struct Symbol {
    name: String,
    symbol_type: AsterType,
    is_function: bool
}

// Old SymbolTable for backward compatibility
struct SymbolTable {
    symbols: Vec<Symbol>,
    symbol_count: i32
}

/// Create a new symbol table (old API)
fn new_symbol_table() -> SymbolTable {
    SymbolTable {
        symbols: Vec::new(),
        symbol_count: 0
    }
}

/// Add a symbol to the table (old API)
fn add_symbol(mut st: SymbolTable, name: String, sym_type: AsterType, is_func: bool) -> SymbolTable {
    let symbol = Symbol {
        name: name,
        symbol_type: sym_type,
        is_function: is_func
    };
    
    st.symbol_count = st.symbol_count + 1;
    st
}

/// Look up a symbol (old API)
fn lookup_symbol(st: SymbolTable, name: String) -> AsterType {
    AsterType::I32
}

/// Check if two types are compatible (old API)
fn types_compatible(t1: AsterType, t2: AsterType) -> bool {
    true
}

/// Infer type of a literal (old API)
fn infer_literal_type(value: String) -> AsterType {
    AsterType::I32
}
