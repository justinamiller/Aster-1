// Aster Compiler Command-Line Interface
// Stage 1 Bootstrap CLI Implementation
// Session 7: Integration & CLI
// Session 9: Connected I/O and utilities stubs

// Generic vector type (provided by runtime)
struct Vec<T> {}

// ============================================================================
// CLI Configuration
// ============================================================================

struct CliConfig {
    input_file: String,
    output_file: String,
    target: i32,  // 1=C, 2=LLVM, 3=Assembly
    verbose: bool,
    help: bool,
    version: bool
}

struct CliResult {
    exit_code: i32,
    message: String
}

// ============================================================================
// Constants
// ============================================================================

let TARGET_C: i32 = 1;
let TARGET_LLVM: i32 = 2;
let TARGET_ASSEMBLY: i32 = 3;

let EXIT_SUCCESS: i32 = 0;
let EXIT_ERROR: i32 = 1;
let EXIT_USAGE: i32 = 2;

let VERSION: String = "Aster Stage 1 Bootstrap Compiler v0.1.0";
let USAGE: String = "Usage: aster [options] <input-file>\n\
Options:\n\
  -o <file>        Output file\n\
  -t <target>      Target (c, llvm, asm)\n\
  -v, --verbose    Verbose output\n\
  -h, --help       Show this help\n\
  --version        Show version\n";

// ============================================================================
// Factory Functions
// ============================================================================

fn new_cli_config() -> CliConfig {
    CliConfig {
        input_file: "",
        output_file: "output.c",
        target: TARGET_C,
        verbose: false,
        help: false,
        version: false
    }
}

fn new_cli_result(code: i32, msg: String) -> CliResult {
    CliResult {
        exit_code: code,
        message: msg
    }
}

// ============================================================================
// Main Entry Point
// ============================================================================

fn main(args: Vec<String>) -> i32 {
    // Parse command-line arguments
    let config = parse_args(args);
    
    // Handle special flags
    if config.version {
        print_version();
        return EXIT_SUCCESS;
    }
    
    if config.help || config.input_file == "" {
        print_usage();
        return if config.help { EXIT_SUCCESS } else { EXIT_USAGE };
    }
    
    // Run compilation
    let result = compile_with_config(config);
    
    // Print result
    if result.message != "" {
        print_message(result.message);
    }
    
    result.exit_code
}

// ============================================================================
// Argument Parsing
// ============================================================================

fn parse_args(args: Vec<String>) -> CliConfig {
    let config = new_cli_config();
    let i = 1; // Skip program name
    
    // TODO: Actual argument parsing loop
    // This is a simplified version
    
    // For now, assume first arg is input file
    if args.len() > 1 {
        config.input_file = args[1];
    }
    
    config
}

fn parse_target(target_str: String) -> i32 {
    if target_str == "c" {
        TARGET_C
    } else if target_str == "llvm" {
        TARGET_LLVM
    } else if target_str == "asm" {
        TARGET_ASSEMBLY
    } else {
        TARGET_C  // Default to C
    }
}

// ============================================================================
// Compilation
// ============================================================================

fn compile_with_config(config: CliConfig) -> CliResult {
    // Print status if verbose
    if config.verbose {
        print_status("Compiling: " + config.input_file);
    }
    
    // Read source file
    let source = read_source_file(config.input_file);
    if source == "" {
        let msg = "Error: Could not read file: " + config.input_file;
        return new_cli_result(EXIT_ERROR, msg);
    }
    
    // Run compilation pipeline
    let compile_result = compile_source(source, config.target);
    
    if !compile_result.success {
        let msg = "Compilation failed with " + int_to_string(compile_result.error_count) + " errors";
        return new_cli_result(EXIT_ERROR, msg);
    }
    
    // Write output file
    let write_ok = write_output_file(config.output_file, compile_result.output_code);
    if !write_ok {
        let msg = "Error: Could not write output file: " + config.output_file;
        return new_cli_result(EXIT_ERROR, msg);
    }
    
    // Success
    if config.verbose {
        print_status("Output written to: " + config.output_file);
    }
    
    new_cli_result(EXIT_SUCCESS, "Compilation successful")
}

// ============================================================================
// File I/O
// ============================================================================

fn read_source_file(filename: String) -> String {
    // Connected to io.ast: read_file uses extern_read_file
    read_file(filename)
}

fn write_output_file(filename: String, content: String) -> bool {
    // Connected to io.ast: write_file uses extern_write_file
    write_file(filename, content)
}

// ============================================================================
// Output Functions
// ============================================================================

fn print_version() {
    print_line(VERSION);
}

fn print_usage() {
    print_line(USAGE);
}

fn print_status(msg: String) {
    print_line("[STATUS] " + msg);
}

fn print_error(msg: String) {
    print_line("[ERROR] " + msg);
}

fn print_message(msg: String) {
    print_line(msg);
}

fn print_line(msg: String) {
    // Connected to runtime: calls extern_print_line for console output
    extern_print_line(msg)
}

// Stub for extern C print function - provided by runtime when linked
// In LLVM IR output, this maps to puts() or equivalent
fn extern_print_line(msg: String) {
    // Runtime-provided: outputs msg + newline to stdout
    // This will be replaced by actual implementation during linking
}

// ============================================================================
// Utility Functions
// ============================================================================

fn int_to_string(n: i32) -> String {
    // Integer to string conversion
    // When compiled with utils.ast, int_to_string_impl() is available
    // Standalone implementation using recursive digit extraction
    if n == 0 { return "0"; }
    if n < 0 { return "-" + int_to_string(-n); }
    let digit = n % 10;
    let rest = n / 10;
    let d = if digit == 0 { "0" } else if digit == 1 { "1" } else if digit == 2 { "2" }
        else if digit == 3 { "3" } else if digit == 4 { "4" } else if digit == 5 { "5" }
        else if digit == 6 { "6" } else if digit == 7 { "7" } else if digit == 8 { "8" }
        else { "9" };
    if rest == 0 { d } else { int_to_string(rest) + d }
}

fn string_concat(a: String, b: String) -> String {
    // String concatenation using + operator
    a + b
}

// ============================================================================
// Integration with Pipeline
// ============================================================================

// CompileResult and compile_source() are provided by pipeline.ast
// (imported when compiled together with pipeline.ast)
// These are declared here as stubs for standalone compilation reference only.

struct CliCompileResult {
    success: bool,
    output_code: String,
    error_count: i32
}

fn cli_compile_source(source: String, target: i32) -> CliCompileResult {
    // Delegates to pipeline.ast's compile_source
    let result = compile_source(source, target);
    CliCompileResult {
        success: result.success,
        output_code: result.output_code,
        error_count: result.error_count
    }
}

// ============================================================================
// Error Handling
// ============================================================================

fn format_compile_errors(errors: Vec<String>) -> String {
    // TODO: Format all errors nicely
    "Compilation errors occurred"
}

fn report_error(phase: String, message: String) {
    print_error(phase + ": " + message);
}

// ============================================================================
// Configuration Helpers
// ============================================================================

fn get_default_output_file(input_file: String, target: i32) -> String {
    // Change extension based on target
    if target == TARGET_C {
        input_file + ".c"
    } else if target == TARGET_LLVM {
        input_file + ".ll"
    } else {
        input_file + ".s"
    }
}

fn validate_config(config: CliConfig) -> bool {
    // Check if input file is specified
    if config.input_file == "" {
        return false;
    }
    
    // Check if target is valid
    if config.target < 1 || config.target > 3 {
        return false;
    }
    
    true
}
