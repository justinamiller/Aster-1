// Option Type - Optional values
// Part of Aster Standard Library - Core Module
//
// Option represents an optional value: every Option is either Some and contains
// a value, or None, and does not. Option types are very common in Aster code, as
// they have a number of uses:
// - Initial values
// - Return values for functions that are not defined over their entire input range
// - Return value for otherwise reporting simple errors
// - Optional struct fields
// - Optional function arguments
//
// Stability: @stable
// Effects: none
// Dependencies: core primitives

/// Type that represents an optional value.
@stable
enum Option<T> {
    /// Some value of type T
    Some(T),
    /// No value
    None
}

/// Creates a Some variant
@stable
fn some<T>(value: T) -> Option<T> {
    Option::Some(value)
}

/// Creates a None variant
@stable
fn none<T>() -> Option<T> {
    Option::None
}

/// Returns true if the option is a Some value
@stable
fn is_some<T>(opt: &Option<T>) -> bool {
    match opt {
        Option::Some(_) => true,
        Option::None => false
    }
}

/// Returns true if the option is a None value
@stable
fn is_none<T>(opt: &Option<T>) -> bool {
    match opt {
        Option::Some(_) => false,
        Option::None => true
    }
}

/// Returns the contained Some value
/// Panics if the value is None
@stable
fn unwrap<T>(opt: Option<T>) -> T {
    match opt {
        Option::Some(val) => val,
        Option::None => panic("called `Option::unwrap()` on a `None` value")
    }
}

/// Returns the contained Some value or a provided default
@stable
fn unwrap_or<T>(opt: Option<T>, default: T) -> T {
    match opt {
        Option::Some(val) => val,
        Option::None => default
    }
}

/// Maps an Option<T> to Option<U> by applying a function to a contained value
@stable
fn map<T, U>(opt: Option<T>, f: fn(T) -> U) -> Option<U> {
    match opt {
        Option::Some(val) => Option::Some(f(val)),
        Option::None => Option::None
    }
}

/// Returns None if the option is None, otherwise calls f with the wrapped value
@stable
fn and_then<T, U>(opt: Option<T>, f: fn(T) -> Option<U>) -> Option<U> {
    match opt {
        Option::Some(val) => f(val),
        Option::None => Option::None
    }
}

/// Returns the option if it contains a value, otherwise returns optb
@stable
fn or<T>(opt: Option<T>, optb: Option<T>) -> Option<T> {
    match opt {
        Option::Some(_) => opt,
        Option::None => optb
    }
}

/// Returns Some if exactly one of self, optb is Some, otherwise returns None
@stable
fn xor<T>(opt: Option<T>, optb: Option<T>) -> Option<T> {
    match opt {
        Option::Some(val) => {
            match optb {
                Option::Some(_) => Option::None,
                Option::None => Option::Some(val)
            }
        },
        Option::None => optb
    }
}
