// Vec - Dynamic array
// Part of Aster Standard Library - Alloc Module
//
// Vec<T> is a growable array type with heap-allocated contents.
//
// Stability: @stable
// Effects: @alloc (performs heap allocation)
// Dependencies: core

/// A contiguous growable array type
@stable
@alloc
struct Vec<T> {
    ptr: *mut T,
    len: usize,
    capacity: usize
}

/// Creates a new empty Vec
@stable
@alloc
fn new_vec<T>() -> Vec<T> {
    Vec {
        ptr: null_mut(),
        len: 0,
        capacity: 0
    }
}

/// Creates a new Vec with the specified capacity
@stable
@alloc
fn with_capacity<T>(capacity: usize) -> Vec<T> {
    if capacity == 0 {
        return new_vec();
    }
    
    let ptr = allocate(capacity * size_of::<T>());
    Vec {
        ptr: ptr as *mut T,
        len: 0,
        capacity: capacity
    }
}

/// Returns the number of elements in the vector
@stable
fn vec_len<T>(v: &Vec<T>) -> usize {
    v.len
}

/// Returns the number of elements the vector can hold without reallocating
@stable
fn vec_capacity<T>(v: &Vec<T>) -> usize {
    v.capacity
}

/// Returns true if the vector contains no elements
@stable
fn vec_is_empty<T>(v: &Vec<T>) -> bool {
    v.len == 0
}

/// Appends an element to the back of the vector
@stable
@alloc
fn push<T>(v: &mut Vec<T>, value: T) {
    if v.len == v.capacity {
        vec_grow(v);
    }
    
    unsafe {
        let ptr = v.ptr.offset(v.len as isize);
        ptr.write(value);
    }
    v.len = v.len + 1;
}

/// Removes the last element from the vector and returns it
/// Panics if the vector is empty
@stable
fn pop<T>(v: &mut Vec<T>) -> Option<T> {
    if v.len == 0 {
        return Option::None;
    }
    
    v.len = v.len - 1;
    unsafe {
        let ptr = v.ptr.offset(v.len as isize);
        Option::Some(ptr.read())
    }
}

/// Returns a reference to an element at the given index
@stable
fn vec_get<T>(v: &Vec<T>, index: usize) -> &T {
    if index >= v.len {
        panic("vec index out of bounds")
    }
    unsafe {
        &*v.ptr.offset(index as isize)
    }
}

/// Returns a mutable reference to an element at the given index
@stable
fn vec_get_mut<T>(v: &mut Vec<T>, index: usize) -> &mut T {
    if index >= v.len {
        panic("vec index out of bounds")
    }
    unsafe {
        &mut *v.ptr.offset(index as isize)
    }
}

/// Clears the vector, removing all values
@stable
fn clear<T>(v: &mut Vec<T>) {
    while v.len > 0 {
        pop(v);
    }
}

/// Reserves capacity for at least additional more elements
@stable
@alloc
fn reserve<T>(v: &mut Vec<T>, additional: usize) {
    let needed = v.len + additional;
    if needed <= v.capacity {
        return;
    }
    
    vec_grow_to(v, needed);
}

/// Grows the vector's capacity
@alloc
fn vec_grow<T>(v: &mut Vec<T>) {
    let new_capacity = if v.capacity == 0 {
        4
    } else {
        v.capacity * 2
    };
    vec_grow_to(v, new_capacity);
}

/// Grows the vector to at least the given capacity
@alloc
fn vec_grow_to<T>(v: &mut Vec<T>, new_capacity: usize) {
    let new_ptr = allocate(new_capacity * size_of::<T>());
    
    if v.len > 0 {
        unsafe {
            memcpy(
                new_ptr as *mut u8,
                v.ptr as *const u8,
                v.len * size_of::<T>()
            );
        }
    }
    
    if v.capacity > 0 {
        deallocate(v.ptr as *mut u8, v.capacity * size_of::<T>());
    }
    
    v.ptr = new_ptr as *mut T;
    v.capacity = new_capacity;
}

/// Returns a slice containing the entire vector
@stable
fn as_slice<T>(v: &Vec<T>) -> &[T] {
    unsafe {
        slice_from_raw_parts(v.ptr as *const T, v.len)
    }
}

/// Returns a mutable slice containing the entire vector
@stable
fn as_mut_slice<T>(v: &mut Vec<T>) -> &mut [T] {
    unsafe {
        slice_from_raw_parts_mut(v.ptr, v.len)
    }
}

impl<T> Drop for Vec<T> {
    fn drop(&mut self) {
        clear(self);
        if self.capacity > 0 {
            deallocate(self.ptr as *mut u8, self.capacity * size_of::<T>());
        }
    }
}

impl<T> IntoIterator for Vec<T> {
    type Item = T;
    type IntoIter = VecIter<T>;
    
    fn into_iter(self) -> VecIter<T> {
        VecIter {
            vec: self,
            index: 0
        }
    }
}

struct VecIter<T> {
    vec: Vec<T>,
    index: usize
}

impl<T> Iterator for VecIter<T> {
    type Item = T;
    
    fn next(&mut self) -> Option<T> {
        if self.index < self.vec.len {
            let value = vec_get(&self.vec, self.index);
            self.index = self.index + 1;
            // Note: This is simplified - real implementation needs ownership transfer
            Option::Some(*value)
        } else {
            Option::None
        }
    }
}

// Placeholder functions (implemented in runtime)
fn allocate(size: usize) -> *mut u8;
fn deallocate(ptr: *mut u8, size: usize);
fn size_of<T>() -> usize;
fn null_mut<T>() -> *mut T;
fn slice_from_raw_parts<T>(ptr: *const T, len: usize) -> &[T];
fn slice_from_raw_parts_mut<T>(ptr: *mut T, len: usize) -> &mut [T];
