// Time module - Clocks and duration
// Layer: time (no alloc, no io)
// Stability: @stable

use core::*;

// Duration type
@stable
pub struct Duration {
    secs: u64,
    nanos: u32,
}

impl Duration {
    @stable
    pub fn new(secs: u64, nanos: u32) -> Duration {
        Duration { secs, nanos }
    }
    
    @stable
    pub fn from_secs(secs: u64) -> Duration {
        Duration { secs, nanos: 0 }
    }
    
    @stable
    pub fn from_millis(millis: u64) -> Duration {
        Duration {
            secs: millis / 1000,
            nanos: ((millis % 1000) * 1_000_000) as u32,
        }
    }
    
    @stable
    pub fn from_micros(micros: u64) -> Duration {
        Duration {
            secs: micros / 1_000_000,
            nanos: ((micros % 1_000_000) * 1_000) as u32,
        }
    }
    
    @stable
    pub fn from_nanos(nanos: u64) -> Duration {
        Duration {
            secs: nanos / 1_000_000_000,
            nanos: (nanos % 1_000_000_000) as u32,
        }
    }
    
    @stable
    pub fn as_secs(&self) -> u64 {
        self.secs
    }
    
    @stable
    pub fn as_millis(&self) -> u64 {
        self.secs * 1000 + (self.nanos / 1_000_000) as u64
    }
    
    @stable
    pub fn as_micros(&self) -> u64 {
        self.secs * 1_000_000 + (self.nanos / 1_000) as u64
    }
    
    @stable
    pub fn as_nanos(&self) -> u64 {
        self.secs * 1_000_000_000 + self.nanos as u64
    }
    
    @stable
    pub fn add(&self, other: &Duration) -> Duration {
        let mut secs = self.secs + other.secs;
        let mut nanos = self.nanos + other.nanos;
        if nanos >= 1_000_000_000 {
            secs += 1;
            nanos -= 1_000_000_000;
        }
        Duration { secs, nanos }
    }
    
    @stable
    pub fn sub(&self, other: &Duration) -> Duration {
        let mut secs = self.secs - other.secs;
        let mut nanos = self.nanos;
        if nanos < other.nanos {
            secs -= 1;
            nanos += 1_000_000_000;
        }
        nanos -= other.nanos;
        Duration { secs, nanos }
    }
}

impl Clone for Duration {
    fn clone(&self) -> Duration {
        Duration {
            secs: self.secs,
            nanos: self.nanos,
        }
    }
}

impl Copy for Duration {}

impl Eq for Duration {
    fn eq(&self, other: &Self) -> bool {
        self.secs == other.secs && self.nanos == other.nanos
    }
}

impl Ord for Duration {
    fn cmp(&self, other: &Self) -> Ordering {
        if self.secs < other.secs {
            Ordering::Less
        } else if self.secs > other.secs {
            Ordering::Greater
        } else if self.nanos < other.nanos {
            Ordering::Less
        } else if self.nanos > other.nanos {
            Ordering::Greater
        } else {
            Ordering::Equal
        }
    }
}

// Instant type (monotonic clock)
@stable
pub struct Instant {
    nanos: u64,
}

impl Instant {
    @stable
    pub fn now() -> Instant {
        Instant {
            nanos: intrinsic_monotonic_nanos(),
        }
    }
    
    @stable
    pub fn elapsed(&self) -> Duration {
        let now = Instant::now();
        Duration::from_nanos(now.nanos - self.nanos)
    }
    
    @stable
    pub fn duration_since(&self, earlier: &Instant) -> Duration {
        Duration::from_nanos(self.nanos - earlier.nanos)
    }
}

// SystemTime type (wall clock)
@stable
pub struct SystemTime {
    secs: i64,
    nanos: u32,
}

impl SystemTime {
    @stable
    pub fn now() -> SystemTime {
        let (secs, nanos) = intrinsic_system_time();
        SystemTime { secs, nanos }
    }
    
    @stable
    pub fn duration_since_epoch(&self) -> Duration {
        Duration::new(self.secs as u64, self.nanos)
    }
}

// Sleep for a duration
@stable
pub fn sleep(duration: Duration) {
    intrinsic_sleep(duration.as_nanos());
}
