using System.Security.Cryptography;
using System.Text;

namespace Aster.Packages;

/// <summary>
/// Lockfile for reproducible builds. Records exact resolved versions and content hashes.
/// </summary>
public sealed class Lockfile
{
    public const string FileName = "aster.lock";

    public List<LockedPackage> Packages { get; set; } = new();

    /// <summary>
    /// Serialize lockfile to a deterministic text format.
    /// </summary>
    public string Serialize()
    {
        var sb = new StringBuilder();
        sb.AppendLine("# This file is auto-generated by aster. Do not edit.");
        sb.AppendLine($"# Generated: {DateTime.UtcNow:O}");
        sb.AppendLine();

        foreach (var pkg in Packages.OrderBy(p => p.Name, StringComparer.Ordinal))
        {
            sb.AppendLine($"[[package]]");
            sb.AppendLine($"name = \"{pkg.Name}\"");
            sb.AppendLine($"version = \"{pkg.Version}\"");
            sb.AppendLine($"content-hash = \"{pkg.ContentHash}\"");
            if (pkg.Source != null)
                sb.AppendLine($"source = \"{pkg.Source}\"");
            if (pkg.Dependencies.Count > 0)
            {
                sb.Append("dependencies = [");
                sb.Append(string.Join(", ", pkg.Dependencies.Select(d => $"\"{d}\"")));
                sb.AppendLine("]");
            }
            sb.AppendLine();
        }

        return sb.ToString();
    }

    /// <summary>
    /// Parse a lockfile from text content.
    /// </summary>
    public static Lockfile Parse(string content)
    {
        var lockfile = new Lockfile();
        LockedPackage? current = null;

        foreach (var line in content.Split('\n'))
        {
            var trimmed = line.Trim();
            if (string.IsNullOrEmpty(trimmed) || trimmed.StartsWith('#'))
                continue;

            if (trimmed == "[[package]]")
            {
                current = new LockedPackage();
                lockfile.Packages.Add(current);
                continue;
            }

            if (current == null) continue;

            var eqIdx = trimmed.IndexOf('=');
            if (eqIdx < 0) continue;

            var key = trimmed[..eqIdx].Trim();
            var value = trimmed[(eqIdx + 1)..].Trim().Trim('"');

            switch (key)
            {
                case "name": current.Name = value; break;
                case "version": current.Version = value; break;
                case "content-hash": current.ContentHash = value; break;
                case "source": current.Source = value; break;
            }
        }

        return lockfile;
    }

    /// <summary>
    /// Compute a content hash for a file or directory.
    /// </summary>
    public static string ComputeContentHash(string path)
    {
        if (File.Exists(path))
        {
            using var stream = File.OpenRead(path);
            var hash = SHA256.HashData(stream);
            return Convert.ToHexStringLower(hash);
        }

        if (Directory.Exists(path))
        {
            using var sha = SHA256.Create();
            var files = Directory.GetFiles(path, "*", SearchOption.AllDirectories)
                .OrderBy(f => f, StringComparer.Ordinal);
            foreach (var file in files)
            {
                var nameBytes = Encoding.UTF8.GetBytes(Path.GetRelativePath(path, file));
                sha.TransformBlock(nameBytes, 0, nameBytes.Length, null, 0);
                var contentBytes = File.ReadAllBytes(file);
                sha.TransformBlock(contentBytes, 0, contentBytes.Length, null, 0);
            }
            sha.TransformFinalBlock(Array.Empty<byte>(), 0, 0);
            return Convert.ToHexStringLower(sha.Hash!);
        }

        return "";
    }
}

/// <summary>
/// A locked package entry with exact version and content hash.
/// </summary>
public sealed class LockedPackage
{
    public string Name { get; set; } = "";
    public string Version { get; set; } = "";
    public string ContentHash { get; set; } = "";
    public string? Source { get; set; }
    public List<string> Dependencies { get; set; } = new();
}
